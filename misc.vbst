IncludeName = "Misc.vbst"
IncludeVersion = "0.07-01"
inc1NameString = IncludeName & " V" & IncludeVersion
say "Including: " & inc1NameString

 set objItems = Nothing
 set objItem = Nothing

{

 '! https://stackoverflow.com/questions/41095060/how-to-get-running-application-name-by-vbscript
 Sub ListProcessRunning()
  'This function can report names from
  'TaskManager -> Processes
     sComputerName = "."
     Set objWMIService = GetObject("winmgmts:\\" & sComputerName & "\root\cimv2")
     sQuery = "SELECT * FROM Win32_Process"
     Set objItems = objWMIService.ExecQuery(sQuery)
     'iterate all item(s)
     For Each objItem In objItems
         WScript.Echo objItem.handle  & " " & objItem.parentprocessid  & " " & objItem.Name & " " & objItem.caption
     Next
End Sub

'! https://books.google.es/books?id=h5pCAwAAQBAJ&pg=PT364&lpg=PT364&dq=vbs+run+sub+in+specific+namespace&source=bl&ots=pTAAIOFlS5&sig=0dbSi9ftRRSKXzEKBinXBv37Rh0&hl=en&sa=X&ved=0ahUKEwjqm43G4trbAhWrJsAKHXNmDXoQ6AEIRzAD#v=onepage&q=vbs%20run%20sub%20in%20specific%20namespace&f=false
'! RecursiveList WMINamespaces.vbs
Sub RListWNspaces()
	say Now
	strComputer = "."
	Call EnumNamespaces ("root", strComputer)
	say "All done " & Now
End Sub ' Sub RListWNspaces()

Sub EnumNamespaces(Nspace, Computer)
	say Nspace
	Set objSWbemServices = GetObject("winmgmts:\\" & Computer & "\" & Nspace)
	Set colNspaces = objSWbemServices.InstancesOf ("__NAMESPACE")
	For Each objNspace in colNspaces
		' Say objNspace.Name&":"
		On Error Resume Next
		Err.Clear
		myErr.Reset
		Call EnumNamespaces (Nspace & "\" & objNspace.Name, Computer)
		
		Err_Number = Err.Number
		If Err.Number <> 0 then
			WScript.StdErr.WriteLine Trim(Err.Description & " (0x" & Hex(Err.Number) & ")")
			myErr.Number = Err.Number
			myErr.Description = Err.Description
			myErr.Source = Err.Source
			ErrArray = Array (Err.Number, Err.Description, Err.Source)
		End If
	
		On Error Goto 0
	
	Next 
End Sub ' Sub EnumNamespaces(Nspace)

'!@ref Tom Laveda 2003, http://computer-programming-forum.com/59-vbscript/bc9ef89b8cb2b879.htm
Function dos (DOSCmd)
  Dim alines, sCmd, stemp, ofs, oWS
  On Error Resume Next
  '  sCmd = """%comspec%"" /c ""%comspec%"" /e:4096 /c " & DOSCmd & " >"
  sCmd = "cmd.exe /c cmd.exe /e:4096 /c " & DOSCmd & " >"
  set ofs = CreateObject("Scripting.FileSystemObject")
  stemp = ofs.GetTempName
  set oWS = CreateObject("Wscript.Shell")
  stemp = oWS.Environment("PROCESS")("TEMP") & "\" & stemp
  'sTemp = "dos.tmp"		' #### DEBUG
  'sayerr "#### Running: oWS.Run " & sCmd & Chr(34) & sTemp & Chr(34) & " 2>&1, 0, true"		' #### DEBUG
  oWS.Run sCmd & Chr(34) & sTemp & Chr(34) & " 2>&1", 0, true

  ' The Original function MSDOS splits each line of outupt into the array alines
  ' alines = Split(ofs.OpenTextFile(stemp).ReadAll, vbNewline)
  ' ReDim Preserve alines(Ubound(alines) - 1)
  ' if Err Then aLines = Split(Empty)

  ' Here, we just return the output directly as a multiline string
  dos = ofs.OpenTextFile(stemp).ReadAll
  ofs.DeleteFile stemp
  if Err Then sayerr "DOS Error"	' This seems to have no effect after redirecting dos errout to stdout

  ' Dirty hack: Fix chr(255) which plagues redirected dos output due to codepage differences
  dos = Replace(dos,chr(255)," ")	
End Function 

Sub saydos (s)
	say dos(s)
End Sub
}

Responsable = " Mr. _Global_ President  "

{
'! Test function vSayLvarq, short vbsCodetoSayLocalVarq
Sub funny (s)
	Dim myvar, Gtest1, Responsable
	myvar = "funny myvar"
	Gtest1 = "funny test1"

	Responsable = " Little _Local_ Red Riding Hood  "
	say VBCrLf&"simple say (unquoted):"
	say "Responsable="&Responsable

	say VBCrLf&"comma dollar say:"
	,say Responsable='$Responsable'

	say VBCrLf&"preprocessed pSayLvarQ:"
	#psaylvarq Responsable

	say VBCrLf&"preprocessed pSayLvarcmQ:"
	#psaylvarcmq Responsable

	say VBCrLf&"preprocessed pSayLvar2cmQ:"
	#psaylvar2cmq Responsable

	say VBCrLf&"preprocessed pSayLvar3cmQ:"
	#psaylvar3cmq Responsable

	say VBCrLf&"with sayvarq:"
	sayvarq "Responsable"

	say VBCrLf&"with manual quotes:"
	say "Responsable='"&Responsable&"'"
	
	say VBCrLf&"with vSayLvarq:"
	execute vSayLvarq ("Responsable")

	Exit Sub

	' ======== DEAD CODE Below ========
	vname = "myvar"
	say vname & "=" & eval(vname)
	sayagain = replace_args("say vname & ""=""  & eval(vname)")

	say "sayagain='"&sayagain&"'"

	say "executing sayagain"
	execute replace (sayagain, """""", """")
	execute vSayLvar  ("myvar")
	'execute locvarq ("myvar")

	sayvarq "Gtest1"
	execute vSayLvar ("Gtest1")
	execute vSayLvarq ("Gtest1")
	sayvarq "Gtest2"
	say Gtest2
	execute vSayLvar ("Gtest2")
	execute vSayLvarq ("Gtest2")
End Sub
}



