
IncludeName = "TestCase.vbst"
IncludeVersion = "0.07-01"
inc1NameString = IncludeName & " V" & IncludeVersion
say "Including: " & inc1NameString

' ====================================================================================================
'_h1 TC - TestCase functions (for automated testing run from .vbst files)
' ====================================================================================================
'_h2 TC TestCase function globals
' ====================================================================================================
	Dim TCnum			: TCnum				= 0			'! Testcase number eg. 1.3.7
	Dim TCtitle			: TCtitle			= 0			'! Testcase title (name)
	Dim TCsubNum		: TCsubNum			= 0			'! sub-Testcase number (plain number 1..n)
	Dim TCsubTitle		: TCsubTitle		= ""		'! sub-Testcase title (name)
	Dim bTCsendLogOn	: bTCsendLogOn		= False		'! bool: Log every command sent to Slave app on/off
	Dim bTCechoOn		: bTCechoOn			= False		'! bool: Echo on/off
	Dim bTCpass			: bTCpass			= False		'! bool: Testcase passed OK yes/no
	Dim sTCexpected		: sTCexpected		= ""		'! Expected string (regex)
	Dim sTCremain		: sTCremain			= ""		'! Remaining string

	Dim TCtotCount		: TCtotCount  		= 0			'! Count of Testcases Executed or attempted
	Dim TCpassCount		: TCpassCount 		= 0			'! Count of Testcases Passed OK
	Dim TCfailCount		: TCfailCount	 	= 0			'! Count of Testcases Failed
	Dim TCSubTotCount	: TCsubTotCount  	= 0			'! Count of sub-Testcases Executed or attempted
	Dim TCsubPassCount	: TCsubPassCount 	= 0			'! Count of sub-Testcases Passed OK
	Dim TCsubFailCount	: TCsubFailCount 	= 0			'! Count of sub-Testcases Failed

	Dim oTCfs			: Set oTCfs			= Nothing	'! object: FileSystem object for manipulating TC log files
	Dim oTClogFile		: Set oTClogFile	= Nothing	'! TC log file (single one, if not using array of logfiles)
	Dim TCfileName		: TCfileName		= ""		'! Name of Test File being executed
	Dim TClogFileName	: TClogFileName		= ""		'! Name of Logfile being written to


	ReDim aTClogFiles (4)								'! array: open TClogFiles (not sure if needed)
	Dim   TClogFilesCount	: TClogFilesCount = 0		'! Count of open TClogFiles  (not sure if needed)


	Dim oTCregx, oTCmatch
	Set oTCregx  = Nothing
	Set oTCmatch = Nothing

{
 If Not TypeName (oTCfs) = "FileSystemObject" Then
	set oTCfs = Nothing
	set oTCfs = CreateObject("Scripting.FileSystemObject")
 End If
}

{

 '! Open TestCase Logfile
 Sub TCopenLogFile (fname)
	' Handle opts: -a append, -r rename (earlier logfiles)...
	' Open logfile
	' Additional housekeeping to activate logging, if any
 End Sub

 '! Close TestCase Logfile and Shell
 Sub TCcloseLogFile (n)
	' Handle opts: ...
	' Close the files
	' Release the objects
	' Additional housekeeping if any
End Sub

'!@ref Tom Laveda 2003, http://computer-programming-forum.com/59-vbscript/bc9ef89b8cb2b879.htm
Function dos (DOSCmd)
  Dim alines, sCmd, stemp, ofs, oWS
  On Error Resume Next
  '  sCmd = """%comspec%"" /c ""%comspec%"" /e:4096 /c " & DOSCmd & " >"
  sCmd = "cmd.exe /c cmd.exe /e:4096 /c " & DOSCmd & " >"
  set ofs = CreateObject("Scripting.FileSystemObject")
  stemp = ofs.GetTempName
  set oWS = CreateObject("Wscript.Shell")
  stemp = oWS.Environment("PROCESS")("TEMP") & "\" & stemp
  'sTemp = "dos.tmp"		' #### DEBUG
  'sayerr "#### Running: oWS.Run " & sCmd & Chr(34) & sTemp & Chr(34) & " 2>&1, 0, true"		' #### DEBUG
  oWS.Run sCmd & Chr(34) & sTemp & Chr(34) & " 2>&1", 0, true

  ' The Original function MSDOS splits each line of outupt into the array alines
  ' alines = Split(ofs.OpenTextFile(stemp).ReadAll, vbNewline)
  ' ReDim Preserve alines(Ubound(alines) - 1)
  ' if Err Then aLines = Split(Empty)

  ' Here, we just return the output directly as a multiline string
  dos = ofs.OpenTextFile(stemp).ReadAll
  ofs.DeleteFile stemp
  if Err Then sayerr "DOS Error"	' This seems to have no effect after redirecting dos errout to stdout

  ' Dirty hack: Fix chr(255) which plagues redirected dos output due to codepage differences
  dos = Replace(dos,chr(255)," ")	
End Function 

Sub saydos (s)
	say dos(s)
End Sub

}

' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0
'_h1 Global RegExpressions for parsing code
	' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O

	'   oRxDlrSubst : Substitution of "Dollar syntax" ie. $varname or ${varname} or ${expression}
	' 	This pattern only matches the first occurrence, independent of what comes before or after
	'Dim oRxDlrSubst 		: Set oRxDlrSubst 		= NewRegExp("\${([a-zA-Z]\w*)}|\$([a-zA-Z]\w*)", 	True, False)
	Dim oRxDlrSubst 		: Set oRxDlrSubst 		= NewRegExp("\${([^}]*)}|\$([^\W0-9]\w*)", 	True, False)

	'   oRxDlr2Eol : Substitution of "Dollar syntax" ie. $varname or ${varname} or ${<expression>}
	' 	Matches from dollar sign to end-of-line. The dollar sign $ must be the first non-blank char on the line
	' 	Returns varname (or expression) in $1$3 and remaining text in $2$4
	Dim oRxDlr2Eol 		: Set oRxDlr2Eol 		= NewRegExp("^[^\S\n]*\${([^}]*)}([\s\S]*)|^[^\S\n]*\$([^\W0-9]\w*)([\s\S]*)$", 	True, False)


	Dim oRxCurlySubst 	: Set oRxCurlySubst 	= NewRegExp("{([^}]*)}([\s\S]*)$|{([\s\S]*)$", 		True, True)
	Dim oRxShSubst 		: Set oRxShSubst 		= NewRegExp("\%{(\w+)}|\%(\w+)%?", 					True, True)

	Dim oRxSplitmark	: Set oRxSplitmark 		= NewRegExp("^([^\$\%\{\""']*)([\s\S]*)$", 	True, False)

	'   oRxSplitDquote	: Match "<text>"<rest>". <text> within double-quotes is returned as $1. <rest> as $2
	Dim oRxSplitDquote	: Set oRxSplitDquote 	= NewRegExp("^([^""]*)""?([\s\S]*)$", 		True, False)
	'   oRxSplitDquote2 : Match "<text>"<rest>". Same as oRxSplitDquote except that the final double-quote is included in $2
	Dim oRxSplitDquote2	: Set oRxSplitDquote2 	= NewRegExp("^([^""]*)([\s\S]*)$", 			True, False)
	'   oRxQuotesx2		: Replace all doublequotes with two double-quotes
	Dim oRxQuotesx2		: Set oRxQuotesx2	 	= NewRegExp("("")", 			True, True)

	Dim oRxRightCurly	: Set oRxRightCurly 	= NewRegExp("^([^}]*)([\s\S]*)$", 			True, False)

	'   oRxCurlyMissing : Match "{<rest-of-string>" with right-curly "}" missing. <rest-of-string> is returned as $1
	' 	Initial left-curly "{" is assumed whether present or not
	Dim oRxCurlyMissing	: Set oRxCurlyMissing 	= NewRegExp("^\s*{?([^}]*)$",	 			True, False)
	'   oRxCurlyEmpty	: Match "{<whitespace-or-empty>}<rest_of_string>". <whitespace-or-empty> returned as $1, <rest_of_string> as $2
	' 	Initial left-curly "{" is assumed whether present or not
	Dim oRxCurlyEmpty	: Set oRxCurlyEmpty 	= NewRegExp("^\s*{?(\s*)}([\s\S]*)$",		True, False)
	
	' #### DEBUG: Remove !!!
	'   oRxCurlyNormal	: Match "{<normal-string>}<rest_of_string>". <normal-string> returned as $1, <rest_of_string> as $2
	' 	Initial left-curly "{" is assumed whether present or not
	' NOT USED:Dim oRxCurlyNormal	: Set oRxCurlyNormal 	= NewRegExp("^\s*{?([^}]*)}([\s\S]*)$",		True, False)


	'   oRxCurlyQ		: Match quoted text within curly-braces. Text before/within/after quotes returned in $1/$2/$3 respectively
	Dim oRxCurlyQ		: Set oRxCurlyQ = NewRegExp("^([^}""]*)(""[^""]*""?)([\s\S]*)$", true, true)
	'   oRxCurlyEnd		: Match normally-ending curly-brace expression . Text within/after end-curly returned in $1/$2 respectively
	Dim oRxCurlyEnd		: Set oRxCurlyEnd = NewRegExp("^([^}""]*)}([\s\S]*)$", true, true)

	' oRxCurlyAdvanced :  used for debugging
	Dim oRxCurlyAdvanced: Set oRxCurlyAdvanced = NewRegExp("^([^\}""]*)(""[^""]*""?)([\s\S]*)$|^([^\}""]*)\}([\s\S]*)$", true, true)




	'Dim oRxIniPunct : Set oRxIniPunct = NewRegExp("^[^\S\n]*[,.;:_\\\|\@\#\~!$%&=?+-*/]", True, True)
	Dim oRxIniPunct : Set oRxIniPunct = NewRegExp("^[^\S\n]*[,.;:_\\\|\@\#\~!$%&=?\+\-\*\/]", True, True)
	'Dim oRxIniToken : Set oRxIniToken = NewRegExp("^([^\S\n]*[a-zA-Z]\w*[^\S\n]?)([\s\S]*)$", True, True)
	Dim oRxIniToken : Set oRxIniToken = NewRegExp("^([^\S\n]*[^\W0-9]\w*[^\S\n]?)([\s\S]*)$", True, True)

	'   oRxIniToken2 : Match "(_@)(_<identifier>_)(<rest of string>)" where "_" is Whitespace, "@" is any punctuation
	' 	Returns: $1 = punctuation (or empty), $2 = identifier (required), $3 = rest of string (or empty)
	Dim oRxIniToken2 : Set oRxIniToken2 = NewRegExp("^([^\S\n]*[^\W0-9]\w*=?[^\S\n]?)([\s\S]*)$", True, True)

	rWSpace="[^\S\n]*"
	rPunct="[,.;:_\\\|\@\#\~!$%&=?\+\-\*\/]"
	rIdfier="[^\W0-9]\w*"

	Dim oRxIniPuncToken : Set oRxIniPuncToken = NewRegExp("^([^\S\n]*[,.;:_\\\|\@\#\~!$%&=?\+\-\*\/])([^\S\n]*[^\W0-9]\w*[^\S\n]?)([\s\S]*)$", True, True)
	Dim oRxWspace	: Set oRxWspace = NewRegExp("^([^\S\n]*)([\s\S]*)$", True, True)

'_/h1 Global RegExpressions for parsing code


' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0	
{ Function cmdsubst (ByRef s)
	Dim token, argstr, remain
	token = ""
	argstr = ""
	remain = ""

	' Remove initial (only one) punctuation character, any of ",.;:_\|@#~!"·$%&=?¿+-*/"
	remain = oRxIniPunct.Replace (s, "")
	If oRxIniToken2.Test (remain) Then
		token  = oRxIniToken2.Replace (remain, "$1")
		remain = oRxIniToken2.Replace (remain, "$2")
	End If
	If Left(remain,1) = " " Then remain = Mid(remain, 2)		' Remove one initial space if present

	remain = argsubst(remain)

	'saydbg "@cmdsubst token="&token
	'saydbg "@cmdsubst remain="&remain
	cmdsubst = token & " " & remain
	'cmdsubst = token & " " & """" & remain & """"

  End Function ' Function cmdsubst (s)
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
}

' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0	
{ Function funcsubst (ByRef s)
	Dim token, argstr, remain
	token = ""
	argstr = ""
	remain = ""

	' Remove initial (only one) punctuation character, any of ",.;:_\|@#~!"·$%&=?¿+-*/"
	remain = oRxIniPunct.Replace (s, "")
	If oRxIniToken.Test (remain) Then
		token  = oRxIniToken.Replace (remain, "$1")
		remain = oRxIniToken.Replace (remain, "$2")
	End If
	If Left(remain,1) = " " Then remain = Mid(remain, 2)		' Remove one initial space if present

	remain = argsubst(remain)

	funcsubst = token & "(" & remain & ")"
	'funcsubst = token & "(""" & remain & """)"

End Function ' Function funcsubst (s)
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
}

' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0	
{ Function argsubst(ByRef s)
	Dim result, leftstr, remain
	result = ""
	leftstr = ""
	remain = s

	i=0
	Do While Not remain = ""
		saydbg   "@argsubst =============================="
		saydbgq  "@argsubst remain="&remain
		leftstr = oRxSplitmark.Replace(remain, "$1")
		remain  = oRxSplitmark.Replace(remain, "$2")
		
		'saydbgq  "@argsubst result="&result
		'saydbgq  "@argsubst leftstr="&leftstr
		'saydbgq  "@argsubst remain="&remain
		splitmark=Left(remain, 1)
		saydbg  "@argsubst splitmark="&splitmark

		' pass the "normal text" in leftstr to the "left side" ie. append it to result
		' NOTE: In some special cases the last character is removed in the logic below
		result = result & leftstr		
		saydbgq  "@argsubst result="&result

		' "escaped" splitmark found ie. it does not count
		' just pass the splitmark to the "left side" ie. append it to result	
		'!@Todo It is NOT possible to have a literal backslash just before a splitmark.
		'!		It could be solved by requiring double backslash, but this is not really acceptable
		'!		since you sometimes need backslashes galore in DOS-style filepaths
		'!		Or doubling them just in the special case where followed by a splitmark, which is a dirty workaround
		'!		So we want "text1\text2\text3\etc" handled as "normal text" ie. appended as-is
		'!		But also "text1\$text2" to be appended as "text1$text2"
		'!		and as a workaround, "text1\\$text2" as "text1\$text2"
		'!		But then if we should want "text1\$var1" appended with var1 substituted it simply can't be done
		'!		Solution: use ^ as an escape cancellation character, removed if found prior to a splitmark char.
		'!			... then "text1\^$var1" appends "text1\" & var1 & " with var1 substituted
		'!			NOW. if you DO want up-arrow in that position, it just needs to be doubled
		'!			so "text1\^^$var1" appends "text1\^" & var1 & " ie. including ^ up-arrow and with var1 substituted
		If Right(result,2) = "^" Then
			' Remove the escape-cancellation character ^ (but if it was doubled ^^ the first one is left in)
			result = Left(result,len(result - 1))
		End If

		' NOTE: For escape-cancellation to work it is IMPORTANT to check end of leftstr here, not of result, 
		If Right(leftstr,1) = "\" Then
			' first remove the escape-mark (backslash) from end of result
			' then append the splitmark as-is
			result = Left(result,len(result - 1)) & splitmark
			remain = Mid(remain, 2)		' remove splitmark from remaining string
	
		ElseIf splitmark = """" Then	' Handle double-quote substring
			result = result & """"""	' "double" the double-quote and append to result
			saydbgq  "@argsubst at start of quote, result="&result
			remain = Mid(remain, 2)		' remove splitmark from remaining string
			' Find closing double-quote
			leftstr = oRxSplitDquote.Replace(remain, "$1")		'Get text up to the next quote, or end of string if no quote found
			remain = oRxSplitDquote.Replace(remain, "$2")		'Get remaining text, after next quote, if quote and any text found
			result = result & leftstr & """"""		' Append quoted string closed with doubled close-quote
			saydbgq  "@argsubst at end of quote, result="&result
			' remain = Mid(remain, 2)		' remove close-quote from remaining string
	
		ElseIf splitmark = "'" Then	'Handle single-quote ie. comment string until eol
			result = result & oRxQuotesx2.Replace (remain, "$1$1")
			remain = ""			' Empty remain will cause immediate exit from loop
								' NOTE: multi-line input not handled here. If so we need to delete only to eol and continue

		ElseIf splitmark = "$" Then	'Handle $varname and ${varname}
			' Extract the first $variable substitution from remain
			' The logic below depends on knowing the fact that the first substitution begins in position 1
			' and after substitution the first double-quote, that we just inserted, will be in char position 1
			oRxDlr2Eol.Global = False
			saydbgq  "@argsubst About to do $substitution, remain="&remain
			leftstr = oRxDlr2Eol.Replace(remain, """ & $1$3 & """)	' extract the replacement <str>, from either format: $str or ${str}
			remain  = oRxDlr2Eol.Replace(remain, "$2$4")			' Remaining text
			qpos = InStr(2, remain, """")			' Find pos of second just-inserted quote char (we know first one is in pos 1 )
					' HOWEVER - This FAILS if the replacement string contained double-quotes
			result = result + leftstr	' append the variable or expression substitution to result
			saydbgq  "@argsubst $substitution done, leftstr="&leftstr
			saydbgq  "@argsubst ...and remaining remain="&remain

		ElseIf splitmark = "%" Then	'Handle %varname, %varname%, %{varname}
			' Extract the first %variable substitution from remain
			' The logic below depends on knowing the fact that the first substitution begins in position 1
			' and after substitution the first double-quote will be in char position 1
			oRxShSubst.Global = False
			' Do just one $substitution (at pos 1 in remain)
			remain = oRxShSubst.Replace(remain, """ & Gosh.ExpandEnvironmentStrings(""%$1$2%"")  & """)
			qpos = InStr(2, remain, ")")			' First right bracket (we know the quote char we want comes right after that )
			qpos = InStr(qpos, remain, """")		' Find pos of the final quote char at end of substitution
			'saydbgq  "@argsubst %substitution done, remain="&remain
			result = result + Left(remain, qpos)	' append the variable substitution to result
			remain = Mid(remain, qpos + 1)			' and remove it from the beginning of remaining str
			'saydbgq  "@argsubst ...and remaining remain="&remain

		ElseIf splitmark = "{" Then	'Handle curly-brace expression {expr}
			remain = Mid(remain, 2)		' remove opening curly-brace from remaining string
			leftstr = ""
			saydbgq  "@argsubst At start of curly: remain="&remain

			If oRxCurlyMissing.Test(remain)  Then
				sayerr "Error: Closing curly-brace missing in line ..."
				sayerrq "remain="&remain
				
			ElseIf oRxCurlyEmpty.Test(remain)  Then
				remain  = oRxCurlyEmpty.Replace (remain, "$2")
				saydbg  "@argsubst Whitespace or empty string withing curly-braces"
				saydbgq  "@argsubst remain="&remain

			Else
				
				If oRxCurlyQ.Test(remain)  Then		' In case of quoted text blocks found within the curly-brace expression:
													'	copy everything up to the last quoted block into leftstr
					saydbgq  "@argsubst Quoted block found in curly: remain="&remain

					Do While oRxCurlyQ.Test(remain) And Not remain = ""
						leftstr = leftstr & oRxCurlyQ.Replace (remain, "$1$2")
						remain = oRxCurlyQ.Replace (remain, "$3")
						saydbgq  "@argsubst leftstr="&leftstr
						If Not Right(leftstr,1) = """" Then
							' Error: End quote not found
							Exit Do
						End If
					Loop
				End If


				If oRxCurlyMissing.Test(remain)  Then		' Test this again: Closing curly-brace missing might have gone undetected above,
															' in case there was one within quotes but not a valid one.
					sayerr "Error: Closing curly-brace missing in line ..."
					sayerrq "remain="&remain
	

				ElseIf oRxCurlyEnd.Test(remain)  Then
					leftstr = leftstr & oRxCurlyEnd.Replace (remain, "$1")
					remain  = oRxCurlyEnd.Replace (remain, "$2")

					' TODO: Test with: a. curly not closed b. curly at end of line c. curly empty {}
					saydbg  "@argsubst ==== about to ExecuteGlobal, input string="&leftstr
					saydbgq "@argsubst remain="&remain

					' Now globalexecute the expression found inside the curly braces

					strictErrExit = False
					On Error Resume Next
					Err.Clear
					'say "ExecuteGlobal (""GsubstVar=""&trim("&leftstr&"))"		' *** DEBUG
					'ExecuteGlobal "GsubstVar="&trim(leftstr)
					' sayq "about to ExecuteGlobal: GsubstVar="""" & "&trim(leftstr)
					ExecuteGlobal "GsubstVar="""" & "&trim(leftstr)
					' GsubstVar = Eval(leftstr)
					If Err.Number <> 0 Then
						sayerr f_error & "Unable to substitute variable or expression: """ & trim(leftstr) & """"
						sayerr Trim(Err.Description & " (0x" & Hex(Err.Number) & ")")
						GsubstVar=""
						If strictErrExit Then		' strictErrExit means quit on first error leaving the whole line unparsed
							Exit Function
						Else 
							' GsubstVar="{" & s & "}" 	' putting the erroneous string back in was an experiment, but not a good idea.
							' This way {<invalid expression>} is just removed, including the curlies
						End If
					End If
					On Error Goto 0
					saydbgq  "@argsubst ==== After ExecuteGlobal, resulting string="&GsubstVar
					result = result & GsubstVar ' Append resulting string (leftstr still holds the original expression before execution)

				Else
					sayerr "Error (argsubst): Internal logic failed in curly-brace expression. Case not covered by existing Regexp strings:"
					sayerrq "Original input string: s="&remain
					sayerrq "Remaining string: remain="&remain

				End If
			End If
		End If

		'remain = Mid(remain, 2)
		i=i+1						' #### DEBUG
		if i > 12 Then Exit Do		' #### DEBUG
	Loop
	
	result = """" & result & """"
	'sayq "result="&result
	argsubst = result
End Function ' Function argsubst(s)
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O

Function argsubs2 (ByRef s)
	argsubs2 = argsubst (s)
	argsubst2 = Mid(argsubs2, 2)
	argsubst2 = Left(argsubs2, Len (argsubs2) - 1)
End Function
}

{

' ====================================================================================================
' ====================================================================================================
' ====================================================================================================
'What I want:
' 1. If logfile not open eg. On starting test run:
' 	a.Create TClogFileName (jst take samename.tclog)
' 	b. Open the file for overwriting or appending (options to rename, append, overwrite)
'		Errors:
'		b1. invalid filename
'		b2. permission violation
'		b3. open failed, other reasons (could be a few)
' 	c. Write initial blurb: Date, Time, name of test object, params(?)
' 2. If logfile already open:
' 	a. Write current log result:
'		a1. Testcase number
'		a2. Testcase name
'		a3. Timestamp (options: each main TC, each sub-TC)
'		a4. Detail on what was tested (options: level of detail)
'		a5. Any comment texts, from TC file
'		a6. TC result: OK, Fail, other (?)
'		a7. Update statistics: TCokCount, TCfailCount, ...Count
'		a8. 
' 	b. For every write
'		b1. Turn Error checking on
'		b2. If error just quit the whole run: Write error could be:
'			b2a. File thought open but wasn't
'			b2b. Permission violation
'			bcc. Disk full
'			b2d. Other...
'		b3. Update housekeeping...
' 3. If at end of test run or chapter:
' 	a. Write out statistics 
' 	d. End and close
 
' ====================================================================================================
Sub TCwriteLogFile (ByRef filePath, ByRef s)
	Const ForReading = 1, ForWriting = 2, ForAppending = 8
	Dim fso, sh, file, fileText, dir
	Dim i, k
	writeHistoryFile = ""

	if filePath = "" then
		sayerr "Error (TCwriteLogFile): FileName not defined."
		exit Sub
	end if

	Set fso = CreateObject("Scripting.FileSystemObject")
	Set file = fso.OpenTextFile(filePath, ForAppending, True)

	file.writeLine(s)
	
	file.Close
	Set fso = Nothing

end Sub ' Sub TCwriteLogFile ()
}


{
 '_h2 TCNew (s) - Start New TestCase: Reset relevant bookkeeping vars and announce in log output
 ' ====================================================================================================
Sub TCNew (s)

	' Decode opts and args
	sArr = Split (Trim(s), " ", 2)
	Dim myLocVar1
	myLocVar1 = "Inside Sub TCNew, called with s='" & s & "'"

	' The following does not display as intended because myLocVar1 is local
	' TClog replace_args ("TCNew saying myLocVar1:{myLocVar1}")
	'.say TCNew saying myLocVar1:{myLocVar1}
    '.say TCNew saying myLocVar1:{myLocVar1}

	' Close and reopen TClogfile for each new TestCase (Only one TC worth of log output is lost in case of error)


	' Set data, Note these vars are all global, reflecting current test case and sub-case
	TCnum		= sArr(0)
	TCtitle		= sArr(1)
	TCsubNum	= 0
	TCtitle2	= ""

	' Log what's going on
	TClog ""
	TClog replace_args ("TestCase: {TCnum} {TCtitle}")
	TClog "===================================================================================================="
End Sub ' Sub TCNew (s)
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
}

' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0	


{
'_h2 TClog (s) - Write to TC log output ie. stdout and any outfiles defined
' ====================================================================================================
' TODO: Outfiles NIY, Also: control verbosity level with global variables
Sub TClog (s)
	say s
	oTClogFile.WriteLine(s)
End Sub ' Sub TClog (s)

Sub TCcheckResult (ByRef line, ByRef expected)
	Dim caption: caption = ""
	TCcheckSubResult caption, line, expected
End Sub ' ...


'_h2 TCcheckSubResult (caption, line, expected) - Check result of TestCase, update bookkeeping and write log outputs
' ====================================================================================================
'!@TODO: ...
'! Options to:
'!		o -i Ignorecase (default is false)
'!		o (Default): Remove the matched pattern (in case it matched)
'!		o -R Do NOT Remove anything
'!		o -l Remove the line where the matched pattern was found
'!		o Remove from beginning up to the matched pattern
'!		o Remove from beginning up to end of line where pattern found
'!		o 
'!		o 
Sub TCcheckSubResult (ByRef caption, ByRef line, ByRef expected)
	' Preparation
	saydbg "@TCcheckResult enter"			' **** DEBUG
	TCsubNum = TCsubNum + 1

	If oTCregx is Nothing then
		Set oTCregx = New RegExp
		oTCregx.global = false
		oTCregx.ignorecase = false
	End If

'	oTCregx.pattern = "(" & expected & ")([\s\S]*)"
	oTCregx.pattern = expected
	saydbg "@TCcheckResult about to execute pattern:" & "(" & expected & ")([\s\S]*)"			' **** DEBUG
	Set oTCmatch = oTCregx.Execute(line)

	
	'	saydbg "@TCcheckResult Now checking if matched or not"			' **** DEBUG
	' Now check if it matched or not
	' If oTCmatch.Count > 0 Then
	If oTCregx.Test(line) Then
		TCsuccess = True
		iTCTotCount  = iTCTotCount  + 1
		iTCFailCount = iTCFailCount + 1
		' Set TCremain to the (.*) part
		'max = oTCmatch(0).submatches.Count-1
		'TCremain = oTCmatch(0).submatches(max)
		TCremain = oTCregx.Replace (line, "")
		line = TCremain
		'TCcheckMessage = argsubs2 ("==== Result: TC-$TCnum $caption OK")
		'TClog argsubs2 ("==== Result: TC-$TCnum $caption OK")
		'.TCcheckMessage= ==== Result: TC-$TCnum $caption OK
		.TCcheckMessage= ==== Result OK: TC-$TCnum.$TCsubNum $caption
		TClog TCcheckMessage
	Else
		TCsuccess = False
		iTCTotCount  = iTCTotCount  + 1
		iTCFailCount = iTCFailCount + 1
		'TClog argsubs2 ("==== Result: TC-$TCnum $caption #### FAILED ####")
		'.TCcheckMessage= ==== Result: TC-$TCnum $caption #### FAILED ####
		.TCcheckMessage= #### FAILED ####: TC-$TCnum.$TCsubNum $caption
		TClog TCcheckMessage

	End If
 End Sub ' Sub TCcheckSubResult (ByRef caption, ByRef line, ByRef expected)
}

