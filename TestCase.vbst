
IncludeName = "TestCase.vbst"
IncludeVersion = "0.06-01"
inc1NameString = IncludeName & " V" & IncludeVersion
say "Including: " & inc1NameString

' ====================================================================================================
'_h1 TC - TestCase funtions (for automated testing run from .vbst files)
' ====================================================================================================
'_h2 TC TestCase funtion globals
' ====================================================================================================
Dim TCnum			: TCnum				= 0			'! Testcase number eg. 1.3.7
Dim TCtitle			: TCtitle			= 0			'! Testcase title (name)
Dim TCsubNum		: TCsubNum			= 0			'! sub-Testcase number (plain number 1..n)
Dim TCsubTitle		: TCsubTitle		= 0			'! sub-Testcase title (name)
Dim bTCsendLogOn	: bTCsendLogOn		= False		'! bool: Log every command sent to Slave app on/off
Dim bTCechoOn		: bTCechoOn			= False		'! bool: Echo on/off
Dim bTCpass			: bTCpass			= False		'! bool: Testcase passed OK yes/no
Dim sTCexpected		: sTCexpected		= ""		'! Expected string (regex)
Dim sTCremain		: sTCremain			= ""		'! Remaining string

Dim TCtotCount		: TCtotCount  		= 0			'! Count of Testcases Executed or attempted
Dim TCpassCount		: TCpassCount 		= 0			'! Count of Testcases Passed OK
Dim TCfailCount		: TCfailCount	 	= 0			'! Count of Testcases Failed
Dim TCSubTotCount	: TCsubTotCount  	= 0			'! Count of sub-Testcases Executed or attempted
Dim TCsubPassCount	: TCsubPassCount 	= 0			'! Count of sub-Testcases Passed OK
Dim TCsubFailCount	: TCsubFailCount 	= 0			'! Count of sub-Testcases Failed

Dim oTCfs			: Set oTCfs			= Nothing	'! object: FileSystem object for manipulating TC log files

ReDim aTClogFiles (4)								'! array: open TClogFiles (not sure if needed)
Dim   TClogFilesCount	: TClogFilesCount = 0		'! Count of open TClogFiles  (not sure if needed)


 Dim oTCregx, oTCmatch
 Set oTCregx  = Nothing
 Set oTCmatch = Nothing
 <:

 '! Open TestCase Logfile and Shell
 Sub TCopenLogFile (fname)
	' Handle opts: -a append, -r rename (earlier logfiles)...
	' Open logfile and shell
	' Attach them to aTCsh and aTCfs arrays
 End Sub

 '! Close TestCase Logfile and Shell
 Sub TCcloseLogFile (n)
	' Handle opts: ...
	' Unattach from aTCsh and aTCfs arrays
	' Close the files
	' Release the objects
 End Sub
:>

<:
 '! : Checking Global_sPipeClass_defined
 If Global_sPipeClass_defined Then
	sayerr "Warning: Class cannot be redefined. Skipping sPipeClass."
	GlobalDiscardNextBlock = True
	' wscript.sleep(500)
 End If
:>   
 
'*wscript.sleep(100)
'*say "Just slept 100"
'If GlobalDiscardNextBlock Then say "GlobalDiscardNextBlock is True"

' Note, without the following line GlobalDiscardNextBlock does not work the first time through here
' 		Starting from the second time it works OK without
'If GlobalDiscardNextBlock Then dummy = 0

'If Global_sPipeClass_defined Then GlobalDiscardNextBlock = True
<:
 ' '!: Silly String Pipe functions - NB: Initial '!: Generates "Direct" .vbst parse-time comment output
 '# If Global_sPipeClass_defined Then GlobalDiscardThisBlock = True
  Global_sPipeClass_defined = True

  '#.say ##############  Wonderful HASHmark Subsitution ################
 ' '!: Just about to declare sPipeClass - NB: Initial '!: Generates "Direct" .vbst parse-time comment output
 class sPipeClass
	Dim Subscribers()
	Dim SubsCount, sBuf

	Sub Write(s)
		' Do stuff
 	End Sub

	Sub Writeline(s)
		' Do stuff
	End Sub
	
	Function GetBuf()
		' Do stuff
	End Function
 	
 End Class

:>

'sayerr "Still running after sPipeClass"

<:

' Prints the time at parse-time, ie. time when this code was read in
Sub saytime1()
 .say Current time1: {Time}
End Sub

' Prints the literal string "Current time1: {Time}" without substitution of {Time}
Sub saytime2()
 say "Current time1: {Time}"
End Sub

' Prints the current time when executed, 
Sub saytime3()
 say "Current time1: " & Time
End Sub


' ====================================================================================================
' ====================================================================================================
' ====================================================================================================
'What I want:
' 1. If logfile not open eg. On starting test run:
' 	a.Create TClogFileName (jst take samename.tclog)
' 	b. Open the file for overwriting or appending (options to rename, append, overwrite)
'		Errors:
'		b1. invalid filename
'		b2. permission violation
'		b3. open failed, other reasons (could be a few)
' 	c. Write initial blurb: Date, Time, name of test object, params(?)
' 2. If logfile already open:
' 	a. Write current log result:
'		a1. Testcase number
'		a2. Testcase name
'		a3. Timestamp (options: each main TC, each sub-TC)
'		a4. Detail on what was tested (options: level of detail)
'		a5. Any comment texts, from TC file
'		a6. TC result: OK, Fail, other (?)
'		a7. Update statistics: TCokCount, TCfailCount, ...Count
'		a8. 
' 	b. For every write
'		b1. Turn Error checking on
'		b2. If error just quit the whole run: Write error could be:
'			b2a. File thought open but wasn't
'			b2b. Permission violation
'			bcc. Disk full
'			b2d. Other...
'		b3. Update housekeeping...
' 3. If at end of test run or chapter:
' 	a. Write out statistics 
' 	d. End and close
 
' ====================================================================================================
Sub TCwriteLogFile (ByRef filePath, ByRef s)
	Const ForReading = 1, ForWriting = 2, ForAppending = 8
	Dim fso, sh, file, fileText, dir
	Dim i, k
	writeHistoryFile = ""

	if filePath = "" then
		sayerr "Error (TCwriteLogFile): FileName not defined."
		exit Sub
	end if

	Set fso = CreateObject("Scripting.FileSystemObject")
	Set file = fso.OpenTextFile(filePath, ForAppending, True)

	file.writeLine(s)
	
	file.Close
	Set fso = Nothing

end Sub ' Sub TCwriteLogFile ()
:>


<:
 '_h2 TCNew (s) - Start New TestCase: Reset relevant bookkeeping vars and announce in log output
 ' ====================================================================================================
Sub TCNew (s)

	' Decode opts and args
	sArr = Split (Trim(s), " ", 2)
	Dim myLocVar1
	myLocVar1 = "Inside Sub TCNew, called with s='" & s & "'"

	' The following does not display as intended because myLocVar1 is local
	' TClog replace_args ("TCNew saying myLocVar1:{myLocVar1}")
	'.say TCNew saying myLocVar1:{myLocVar1}
    '.say TCNew saying myLocVar1:{myLocVar1}


	' Set data, Note these vars are all global, reflecting current test case and sub-case
	TCnum     = sArr(0)
	TCtitle   = sArr(1)
	TCnumber2 = ""		' sub-number and -title
	TCtitle2  = ""

	' Log what's going on
	TClog ""
	TClog replace_args ("TestCase: {TCnum} {TCtitle}")
	TClog "===================================================================================================="
End Sub ' Sub TCNew (s)
:>
<:
'_h2 TClog (s) - Write to TC log output ie. stdout and any outfiles defined
' ====================================================================================================
' TODO: Outfiles NIY, Also: control verbosity level with global variables
Sub TClog (s)
	say s
	'NIY:write2logfile s
End Sub ' Sub TClog (s)

'_h2 TCcheckResult (line, expected) - Check result of TestCase, update bookkeeping and write log outputs
' ====================================================================================================
'!@TODO: ...
'! Options to:
'!		o -i Ignorecase (default is false)
'!		o (Default): Remove the matched pattern
'!		o -R Do NOT Remove anything
'!		o -l Remove the line where the matched pattern was found
'!		o Remove from beginning up to the matched pattern
'!		o Remove from beginning up to end of line where pattern found
'!		o 
'!		o 
Sub TCcheckResult (ByRef line, expected)
	' Preparation
	' saydbg "TCcheckResult enter"			' **** DEBUG
	If oTCregx is Nothing then
		Set oTCregx = New RegExp
		oTCregx.global = false
		oTCregx.ignorecase = false
	End If

'	oTCregx.pattern = "(" & expected & ")([\s\S]*)"
	oTCregx.pattern = expected
	'	saydbg "TCcheckResult about to execute pattern:" & "(" & expected & ")([\s\S]*)"			' **** DEBUG
	Set oTCmatch = oTCregx.Execute(line)

	
	'	saydbg "Now checking if matched or not"			' **** DEBUG
	' Now check if it matched or not
	' If oTCmatch.Count > 0 Then
	If oTCregx.Test(line) Then
		TCsuccess = True
		iTCTotCount  = iTCTotCount  + 1
		iTCFailCount = iTCFailCount + 1
		' Set TCremain to the (.*) part
		'max = oTCmatch(0).submatches.Count-1
		'TCremain = oTCmatch(0).submatches(max)
		TCremain = oTCregx.Replace (line, "")
		TClog replace_args ("==== Result: TC-{TCnum} OK")
	Else
		TCsuccess = False
		iTCTotCount  = iTCTotCount  + 1
		iTCFailCount = iTCFailCount + 1
		TClog replace_args ("==== Result: TC-{TCnum} #### FAILED ####")

	End If
 End Sub ' Sub TCcheckResult (line, expected)

 Set dir = Getref("ls")

 Sub ls (s)
	Set FSO = CreateObject("Scripting.FileSystemObject")
	Set objFolder = FSO.GetFolder(FSO.GetParentFolderName(WScript.ScriptFullName))
	Set allFiles = objFolder.Files
	For Each objFile in allFiles
		Wscript.StdOut.Write objFile.Name & " "
	Next
	Wscript.StdOut.WriteLine ""
 End Sub

 Sub fpath (s)
	Set fso = CreateObject("Scripting.FileSystemObject")
 	Set sh = CreateObject("WScript.Shell")

	For Each d In Split(sh.ExpandEnvironmentStrings("%PATH%"), ";")
		Wscript.StdOut.WriteLine d
		' TODO: 
		'		- Filter based on search string
		'		- Check if dir exists and mark with asterisk * or something 
		'		- Detect repeated items
		'		- Functions to add and remove stuff (?)

	Next
 End Sub




 :>

