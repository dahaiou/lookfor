
IncludeName = "TestCase.vbst"
IncludeVersion = "0.07-01"
inc1NameString = IncludeName & " V" & IncludeVersion
say "Including: " & inc1NameString

' ====================================================================================================
'_h1 TC - TestCase functions (for automated testing run from .vbst files)
' ====================================================================================================
'_h2 TC TestCase function globals
' ====================================================================================================
	Dim TCnum			: TCnum				= 0			'! Testcase number eg. 1.3.7
	Dim TCtitle			: TCtitle			= 0			'! Testcase title (name)
	Dim TCsubNum		: TCsubNum			= 0			'! sub-Testcase number (plain number 1..n)
	Dim TCsubTitle		: TCsubTitle		= ""		'! sub-Testcase title (name)
	Dim bTCsendLogOn	: bTCsendLogOn		= False		'! bool: Log every command sent to Slave app on/off
	Dim bTCechoOn		: bTCechoOn			= False		'! bool: Echo on/off
	Dim bTCpass			: bTCpass			= False		'! bool: Testcase passed OK yes/no
	Dim sTCexpected		: sTCexpected		= ""		'! Expected string (regex)
	Dim sTCremain		: sTCremain			= ""		'! Remaining string

	Dim TCtotCount		: TCtotCount  		= 0			'! Count of Testcases Executed or attempted
	Dim TCpassCount		: TCpassCount 		= 0			'! Count of Testcases Passed OK
	Dim TCfailCount		: TCfailCount	 	= 0			'! Count of Testcases Failed
	Dim TCSubTotCount	: TCsubTotCount  	= 0			'! Count of sub-Testcases Executed or attempted
	Dim TCsubPassCount	: TCsubPassCount 	= 0			'! Count of sub-Testcases Passed OK
	Dim TCsubFailCount	: TCsubFailCount 	= 0			'! Count of sub-Testcases Failed

	Dim oTCfs			: Set oTCfs			= Nothing	'! object: FileSystem object for manipulating TC log files
	Dim oTClogFile		: Set oTClogFile	= Nothing	'! TC log file (single one, if not using array of logfiles)
	Dim TCfileName		: TCfileName		= ""		'! Name of Test File being executed
	Dim TClogFileName	: TClogFileName		= ""		'! Name of Logfile being written to


	ReDim aTClogFiles (4)								'! array: open TClogFiles (not sure if needed)
	Dim   TClogFilesCount	: TClogFilesCount = 0		'! Count of open TClogFiles  (not sure if needed)


	Dim oTCregx, oTCmatch
	Set oTCregx  = Nothing
	Set oTCmatch = Nothing

{
 If Not TypeName (oTCfs) = "FileSystemObject" Then
	set oTCfs = Nothing
	set oTCfs = CreateObject("Scripting.FileSystemObject")
 End If
}

{

 '! Open TestCase Logfile
 Sub TCopenLogFile (fname)
	' Handle opts: -a append, -r rename (earlier logfiles)...
	' Open logfile
	' Additional housekeeping to activate logging, if any
 End Sub

 '! Close TestCase Logfile and Shell
 Sub TCcloseLogFile (n)
	' Handle opts: ...
	' Close the files
	' Release the objects
	' Additional housekeeping if any
End Sub

'!@ref Tom Laveda 2003, http://computer-programming-forum.com/59-vbscript/bc9ef89b8cb2b879.htm
Function dos (DOSCmd)
  Dim alines, sCmd, stemp, ofs, oWS
  On Error Resume Next
  '  sCmd = """%comspec%"" /c ""%comspec%"" /e:4096 /c " & DOSCmd & " >"
  sCmd = "cmd.exe /c cmd.exe /e:4096 /c " & DOSCmd & " >"
  set ofs = CreateObject("Scripting.FileSystemObject")
  stemp = ofs.GetTempName
  set oWS = CreateObject("Wscript.Shell")
  stemp = oWS.Environment("PROCESS")("TEMP") & "\" & stemp
  'sTemp = "dos.tmp"		' #### DEBUG
  'sayerr "#### Running: oWS.Run " & sCmd & Chr(34) & sTemp & Chr(34) & " 2>&1, 0, true"		' #### DEBUG
  oWS.Run sCmd & Chr(34) & sTemp & Chr(34) & " 2>&1", 0, true

  ' The Original function MSDOS splits each line of outupt into the array alines
  ' alines = Split(ofs.OpenTextFile(stemp).ReadAll, vbNewline)
  ' ReDim Preserve alines(Ubound(alines) - 1)
  ' if Err Then aLines = Split(Empty)

  ' Here, we just return the output directly as a multiline string
  dos = ofs.OpenTextFile(stemp).ReadAll
  ofs.DeleteFile stemp
  if Err Then sayerr "DOS Error"	' This seems to have no effect after redirecting dos errout to stdout

  ' Dirty hack: Fix chr(255) which plagues redirected dos output due to codepage differences
  dos = Replace(dos,chr(255)," ")	
End Function ' Function dos (DOSCmd) 

Sub saydos (s)
	say dos(s)
End Sub

}

' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0
'_h1 Global RegExpressions for parsing code
	' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O

	'   oRxDlrSubst : Substitution of "Dollar syntax" ie. $varname or ${varname} or ${expression}
	' 	This pattern only matches the first occurrence, independent of what comes before or after
	'Dim oRxDlrSubst 		: Set oRxDlrSubst 		= NewRegExp("\${([a-zA-Z]\w*)}|\$([a-zA-Z]\w*)", 	True, False)
	Dim oRxDlrSubst 		: Set oRxDlrSubst 		= NewRegExp("\${([^}]*)}|\$([^\W0-9]\w*)", 	True, False)

	'   oRxDlr2Eol : Substitution of "Dollar syntax" ie. $varname or ${varname} or ${<expression>}
	' 	Matches from dollar sign to end-of-line. The dollar sign $ must be the first non-blank char on the line
	' 	Returns varname (or expression) in $1$3 and remaining text in $2$4
	'	(HS 2018-08-17): Initial dot "." or dot elsewhere is now valid as part of varname (eg. "$.varname" in a with-block)
	'					 However: varname MUST have an identifier character (a-zA-Z_) as first character (or as second, if initial dot is present)
	Dim oRxDlr2Eol 		: Set oRxDlr2Eol 		= NewRegExp("^[^\S\n]*\${([^}]*)}([\s\S]*)|^[^\S\n]*\$(\.?[^\W0-9][\w\.]*)([\s\S]*)$", 	True, False)

	' Trailing dots that may appear in varname after using oRxDlr2Eol above:
	Dim oRxTailDots		: Set oRxTailDots		= NewRegExp("^(\.?[^\W0-9][\w\.]*[^\.])(\.*)(\n|$)|^(\.?[^\W0-9])(\.*)(\n|$)", 	True, False)

	Dim oRxCurlySubst 	: Set oRxCurlySubst 	= NewRegExp("{([^}]*)}([\s\S]*)$|{([\s\S]*)$", 		True, True)
	Dim oRxShSubst 		: Set oRxShSubst 		= NewRegExp("\%{(\w+)}|\%(\w+)%?", 					True, True)

	Dim oRxSplitmark	: Set oRxSplitmark 		= NewRegExp("^([^\$\%\{\""']*)([\s\S]*)$", 	True, False)

	'   oRxSplitDquote	: Match "<text>"<rest>". <text> within double-quotes is returned as $1. <rest> as $2
	Dim oRxSplitDquote	: Set oRxSplitDquote 	= NewRegExp("^([^""]*)""?([\s\S]*)$", 		True, False)
	'   oRxSplitDquote2 : Match "<text>"<rest>". Same as oRxSplitDquote except that the final double-quote is included in $2
	Dim oRxSplitDquote2	: Set oRxSplitDquote2 	= NewRegExp("^([^""]*)([\s\S]*)$", 			True, False)
	'   oRxQuotesx2		: Replace all doublequotes with two double-quotes
	Dim oRxQuotesx2		: Set oRxQuotesx2	 	= NewRegExp("("")", 			True, True)

	Dim oRxRightCurly	: Set oRxRightCurly 	= NewRegExp("^([^}]*)([\s\S]*)$", 			True, False)

	'   oRxCurlyMissing : Match "{<rest-of-string>" with right-curly "}" missing. <rest-of-string> is returned as $1
	' 	Initial left-curly "{" is assumed whether present or not
	Dim oRxCurlyMissing	: Set oRxCurlyMissing 	= NewRegExp("^\s*{?([^}]*)$",	 			True, False)
	'   oRxCurlyEmpty	: Match "{<whitespace-or-empty>}<rest_of_string>". <whitespace-or-empty> returned as $1, <rest_of_string> as $2
	' 	Initial left-curly "{" is assumed whether present or not
	Dim oRxCurlyEmpty	: Set oRxCurlyEmpty 	= NewRegExp("^\s*{?(\s*)}([\s\S]*)$",		True, False)
	
	' #### DEBUG: Remove !!!
	'   oRxCurlyNormal	: Match "{<normal-string>}<rest_of_string>". <normal-string> returned as $1, <rest_of_string> as $2
	' 	Initial left-curly "{" is assumed whether present or not
	' NOT USED:Dim oRxCurlyNormal	: Set oRxCurlyNormal 	= NewRegExp("^\s*{?([^}]*)}([\s\S]*)$",		True, False)


	'   oRxCurlyQ		: Match quoted text within curly-braces. Text before/within/after quotes returned in $1/$2/$3 respectively
	Dim oRxCurlyQ		: Set oRxCurlyQ = NewRegExp("^([^}""]*)(""[^""]*""?)([\s\S]*)$", true, true)
	'   oRxCurlyEnd		: Match normally-ending curly-brace expression . Text within/after end-curly returned in $1/$2 respectively
	Dim oRxCurlyEnd		: Set oRxCurlyEnd = NewRegExp("^([^}""]*)}([\s\S]*)$", true, true)

	' oRxCurlyAdvanced :  used for debugging
	Dim oRxCurlyAdvanced: Set oRxCurlyAdvanced = NewRegExp("^([^\}""]*)(""[^""]*""?)([\s\S]*)$|^([^\}""]*)\}([\s\S]*)$", true, true)




	'Dim oRxIniPunct : Set oRxIniPunct = NewRegExp("^[^\S\n]*[,.;:_\\\|\@\#\~!$%&=?+-*/]", True, True)
	Dim oRxIniPunct : Set oRxIniPunct = NewRegExp("^[^\S\n]*[,.;:_\\\|\@\#\~!$%&=?\+\-\*\/]", True, True)
	'Dim oRxIniToken : Set oRxIniToken = NewRegExp("^([^\S\n]*[a-zA-Z]\w*[^\S\n]?)([\s\S]*)$", True, True)
	'Dim oRxIniToken : Set oRxIniToken = NewRegExp("^([^\S\n]*[^\W0-9]\w*[^\S\n]?)([\s\S]*)$", True, True)
	Dim oRxIniToken : Set oRxIniToken = NewRegExp("^([^\S\n]*\.?[^\W0-9][\w\.]*=?[^\S\n]?)([\s\S]*)$", True, True)

	'   oRxIniToken2 : Match "(_@_<identifier>_)(<rest of string>)" where "_" is Whitespace, "@" is any punctuation
	' 	Returns: $1 = Initial token (required), $2 = rest of string (or empty)
	'	(HS 2018-08-17): Initial dot "." or dot elsewhere is now valid as part of token name (eg. ".varname" in a with-block)
	'					 However: Token MUST have an identifier character (a-zA-Z_) as first character (or as second, if initial dot is present)
	'					 A final equal sign "=" is accepted as part of token (for assignment statements)
	Dim oRxIniToken2 : Set oRxIniToken2 = NewRegExp("^([^\S\n]*\.?[^\W0-9][\w\.]*=?[^\S\n]?)([\s\S]*)$", True, True)

	rWSpace="[^\S\n]*"
	rPunct="[,.;:_\\\|\@\#\~!$%&=?\+\-\*\/]"
	' NOTE: dot "." must be accepted as part of identifier
	'		Even _initial_ dot is possible, as it could be within a With-block
	rIdfier="\.?[^\W0-9][\w\.]*"

	Dim oRxIniPuncToken : Set oRxIniPuncToken = NewRegExp("^([^\S\n]*[,.;:_\\\|\@\#\~!$%&=?\+\-\*\/])([^\S\n]*[^\W0-9]\w*[^\S\n]?)([\s\S]*)$", True, True)
	Dim oRxWspace	: Set oRxWspace = NewRegExp("^([^\S\n]*)([\s\S]*)$", True, True)

'_/h1 Global RegExpressions for parsing code


' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0	
{ Function cmdsubst (ByRef s)
	Dim opts, token, argstr, remain

	getIniOpts ":U", s, opts

	token = ""
	argstr = ""
	remain = s
	saydbgq "@cmdsubst called s="&s

	If Not find_opt("U", opts) Then remain = uncomment(remain)

	' Remove initial (only one) punctuation character, any of ",.;:_\|@#~!"·$%&=?¿+-*/"
	remain = oRxIniPunct.Replace (remain, "")
	If oRxIniToken2.Test (remain) Then
		token  = oRxIniToken2.Replace (remain, "$1")
		remain = oRxIniToken2.Replace (remain, "$2")
	End If
	If Left(remain,1) = " " Then remain = Mid(remain, 2)		' Remove one initial space if present

	remain = argsubst(remain)

	saydbg "@cmdsubst token="&token
	saydbg "@cmdsubst remain="&remain
	cmdsubst = token & " " & remain
	'cmdsubst = token & " " & """" & remain & """"

  End Function ' Function cmdsubst (s)
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
}

' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0	
'! Turn '*<functionName> <rest of line>' into 'functionName ("<argsubst(rest of line)>")'
'! where "*" represents _any_ punctuation character.
'! Initial punctuation character and trailing comments are removed (except with option -U)
'! and <rest of line> is processed by argument substitution (sub argsubst)
'! eg. '%myclass.setfilename filename' becomes 'myclass.setfilename ("filename")'
'! Options: -U Do NOT eliminate trailing comment from end of line
{ Function funcsubst (ByRef s)
	Dim opts, token, argstr, remain

  	getIniOpts ":U", s, opts

	token = ""
	argstr = ""
	remain = s

	If Not find_opt("U", opts) Then remain = uncomment(remain)

	' Remove initial (only one) punctuation character, any of ",.;:_\|@#~!"·$%&=?¿+-*/"
	remain = oRxIniPunct.Replace (remain, "")
	If oRxIniToken.Test (remain) Then
		token  = oRxIniToken.Replace (remain, "$1")
		remain = oRxIniToken.Replace (remain, "$2")
	End If
	If Left(remain,1) = " " Then remain = Mid(remain, 2)		' Remove one initial space if present

	remain = argsubst(remain)

	funcsubst = token & "(" & remain & ")"
	'funcsubst = token & "(""" & remain & """)"

End Function ' Function funcsubst (s)
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
}

' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0	
{ Function argsubst(ByRef s)
	Dim result, leftstr, remain, r1, result0, remain0, i, stagCount
	result0 = ""
	remain0 = ""	

	result = ""
	leftstr = ""
	remain = s

	i=0
	stagCount = 0

	Do While Not remain = ""
		saydbg   "@argsubst =============================="
		saydbgq  "@argsubst remain="&remain
		leftstr = oRxSplitmark.Replace(remain, "$1")
		remain  = oRxSplitmark.Replace(remain, "$2")
		
		'saydbgq  "@argsubst result="&result
		'saydbgq  "@argsubst leftstr="&leftstr
		'saydbgq  "@argsubst remain="&remain
		splitmark=Left(remain, 1)
		'saydbg  "@argsubst splitmark="&splitmark

		' pass the "normal text" in leftstr to the "left side" ie. append it to result
		' NOTE: In some special cases the last character is removed in the logic below
		result = result & leftstr		
		'saydbgq  "@argsubst result="&result

		saydbgq  "@argsubst /result/splitmark/leftstr/remain/ = /" & result & "/" & splitmark & "/" & leftstr & "/" & remain & "/"

		' "escaped" splitmark found ie. it does not count
		' just pass the splitmark to the "left side" ie. append it to result	
		'!@Todo It is NOT possible to have a literal backslash just before a splitmark.
		'!		It could be solved by requiring double backslash, but this is not really acceptable
		'!		since you sometimes need backslashes galore in DOS-style filepaths
		'!		Or doubling them just in the special case where followed by a splitmark, which is a dirty workaround
		'!		So we want "text1\text2\text3\etc" handled as "normal text" ie. appended as-is
		'!		But also "text1\$text2" to be appended as "text1$text2"
		'!		and as a workaround, "text1\\$text2" as "text1\$text2"
		'!		But then if we should want "text1\$var1" appended with var1 substituted it simply can't be done
		'!		Solution: use ^ as an escape cancellation character, removed if found prior to a splitmark char.
		'!			... then "text1\^$var1" appends "text1\" & var1 & " with var1 substituted
		'!			NOW. if you DO want up-arrow in that position, it just needs to be doubled
		'!			so "text1\^^$var1" appends "text1\^" & var1 & " ie. including ^ up-arrow and with var1 substituted
		If Right(result,1) = "^" Then
			' Remove the escape-cancellation character ^ (but if it was doubled ^^ the first one is left in)
			saydbgq "@argsubst Excape cancellation ^ found: /result/splitmark/leftstr/remain/ = /" & result & "/" & splitmark & "/" & leftstr & "/" & remain & "/"
			result = Left(result,len(result) - 1)
		End If

		' NOTE: For escape-cancellation to work it is IMPORTANT to check end of leftstr here, not of result, 
		If Right(leftstr,1) = "\" Then
			saydbgq "@argsubst Backslash found: /result/splitmark/leftstr/remain/ = /" & result & "/" & splitmark & "/" & leftstr & "/" & remain & "/"
			' first remove the escape-mark (backslash) from end of result
			' then append the splitmark as-is
			result = Left(result,len(result) - 1) & splitmark
			remain = Mid(remain, 2)		' remove splitmark from remaining string
	
		ElseIf splitmark = """" Then	' Handle double-quote substring
			result = result & """"""	' "double" the double-quote and append to result
			saydbgq  "@argsubst at start of quote, result="&result
			remain = Mid(remain, 2)		' remove splitmark from remaining string
			' Find closing double-quote
			leftstr = oRxSplitDquote.Replace(remain, "$1")		'Get text up to the next quote, or end of string if no quote found
			remain = oRxSplitDquote.Replace(remain, "$2")		'Get remaining text, after next quote, if quote and any text found
			result = result & leftstr & """"""		' Append quoted string closed with doubled close-quote
			saydbgq  "@argsubst at end of quote, result="&result
			' remain = Mid(remain, 2)		' remove close-quote from remaining string
	
		ElseIf splitmark = "a" Then	'Handle single-quote ie. comment string until eol
			saydbgq "@argsubst Comment indicator found: /result/splitmark/leftstr/remain/ = /" & result & "/" & splitmark & "/" & leftstr & "/" & remain & "/"
			result = result & oRxQuotesx2.Replace (remain, "$1$1")
			remain = ""			' Empty remain will cause immediate exit from loop
								' NOTE: multi-line input not handled here. If so we need to delete only to eol and continue

		ElseIf splitmark = "$" Then	'Handle $varname and ${varname}
			' Extract the first $variable substitution from remain
			' The logic below depends on knowing the fact that the first substitution begins in position 1
			' and after substitution the first double-quote, that we just inserted, will be in char position 1
			r1 = Mid (remain, 2, 1)
			saydbgq  "@argsubst About to do $substitution, remain="&remain
			leftstr = oRxDlr2Eol.Replace(remain, "$1$3")	' extract the replacement <str>, from either format: $str or ${str}
			remain  = oRxDlr2Eol.Replace(remain, "$2$4")	' Remaining text

			' Reject trailing dots from the varname in leftstr (applies only to the $varname syntax, not ${varname})
			' Rejection happens by removing them from the end of leftstr and sticking back in at the beginning of remain
			If Not r1 = "{" Then 

				tdots = false																					' #### DEBUG
				If Right(leftstr, 1) = "." Then 
					tdots = true				' #### DEBUG
					saydbgq		"@argsubst BEFORE: Trailing dots rejection, leftstr= '" & leftstr		' #### DEBUG
					saydbgq		"@argsubst remain ='" & remain										' #### DEBUG
				End If


				remain	= oRxTailDots.Replace(leftstr, "$2$5") & remain
				leftstr = oRxTailDots.Replace(leftstr, "$1$4")

				If tdots Then
					saydbgq		"@argsubst AFTER: leftstr= '" & leftstr		' #### DEBUG
					saydbgq		"@argsubst remain ='" & remain										' #### DEBUG
				End If

			End If
			
			'result = result & "" & leftstr & ""	' append the variable or expression substitution to result
			result = result & """ & " & leftstr & " & """	' append the variable or expression substitution to result
			saydbgq  "@argsubst $substitution done, leftstr="&leftstr
			saydbgq  "@argsubst ...and remaining remain="&remain

		ElseIf splitmark = "%" Then	'Handle %varname, %varname%, %{varname}
			' Extract the first %variable substitution from remain
			' The logic below depends on knowing the fact that the first substitution begins in position 1
			' and after substitution the first double-quote will be in char position 1
			oRxShSubst.Global = False
			' Do just one $substitution (at pos 1 in remain)
			remain = oRxShSubst.Replace(remain, """ & Gosh.ExpandEnvironmentStrings(""%$1$2%"")  & """)
			qpos = InStr(2, remain, ")")			' First right bracket (we know the quote char we want comes right after that )
			qpos = InStr(qpos, remain, """")		' Find pos of the final quote char at end of substitution
			'saydbgq  "@argsubst %substitution done, remain="&remain
			result = result + Left(remain, qpos)	' append the variable substitution to result
			remain = Mid(remain, qpos + 1)			' and remove it from the beginning of remaining str
			'saydbgq  "@argsubst ...and remaining remain="&remain

		ElseIf splitmark = "{" Then	'Handle curly-brace expression {expr}
			remain = Mid(remain, 2)		' remove opening curly-brace from remaining string
			leftstr = ""
			saydbgq  "@argsubst At start of curly: remain="&remain

			If oRxCurlyMissing.Test(remain)  Then
				sayerr "Error: Closing curly-brace missing in line ..."
				sayerrq "remain="&remain
				
			ElseIf oRxCurlyEmpty.Test(remain)  Then
				remain  = oRxCurlyEmpty.Replace (remain, "$2")
				saydbg  "@argsubst Whitespace or empty string withing curly-braces"
				saydbgq  "@argsubst remain="&remain

			Else
				
				If oRxCurlyQ.Test(remain)  Then		' In case of quoted text blocks found within the curly-brace expression:
													'	copy everything up to the last quoted block into leftstr
					saydbgq  "@argsubst Quoted block found in curly: remain="&remain

					Do While oRxCurlyQ.Test(remain) And Not remain = ""
						leftstr = leftstr & oRxCurlyQ.Replace (remain, "$1$2")
						remain = oRxCurlyQ.Replace (remain, "$3")
						saydbgq  "@argsubst leftstr="&leftstr
						If Not Right(leftstr,1) = """" Then
							' Error: End quote not found
							Exit Do
						End If
					Loop
				End If


				If oRxCurlyMissing.Test(remain)  Then		' Test this again: Closing curly-brace missing might have gone undetected above,
															' in case there was one within quotes but not a valid one.
					sayerr "Error: Closing curly-brace missing in line ..."
					sayerrq "remain="&remain
	

				ElseIf oRxCurlyEnd.Test(remain)  Then
					leftstr = leftstr & oRxCurlyEnd.Replace (remain, "$1")
					remain  = oRxCurlyEnd.Replace (remain, "$2")

					' TODO: Test with: a. curly not closed b. curly at end of line c. curly empty {}
					saydbg  "@argsubst ==== about to ExecuteGlobal, input string="&leftstr
					saydbgq "@argsubst remain="&remain

					' Now globalexecute the expression found inside the curly braces

					strictErrExit = False
					On Error Resume Next
					Err.Clear
					'say "ExecuteGlobal (""GsubstVar=""&trim("&leftstr&"))"		' *** DEBUG
					'ExecuteGlobal "GsubstVar="&trim(leftstr)
					' sayq "about to ExecuteGlobal: GsubstVar="""" & "&trim(leftstr)
					ExecuteGlobal "GsubstVar="""" & "&trim(leftstr)
					' GsubstVar = Eval(leftstr)
					If Err.Number <> 0 Then
						sayerr f_error & "Unable to substitute variable or expression: """ & trim(leftstr) & """"
						sayerr Trim(Err.Description & " (0x" & Hex(Err.Number) & ")")
						GsubstVar=""
						If strictErrExit Then		' strictErrExit means quit on first error leaving the whole line unparsed
							Exit Function
						Else 
							' GsubstVar="{" & s & "}" 	' putting the erroneous string back in was an experiment, but not a good idea.
							' This way {<invalid expression>} is just removed, including the curlies
						End If
					End If
					On Error Goto 0
					saydbgq  "@argsubst ==== After ExecuteGlobal, resulting string="&GsubstVar
					result = result & GsubstVar ' Append resulting string (leftstr still holds the original expression before execution)

				Else
					sayerr "Error (argsubst): Internal logic failed in curly-brace expression. Case not covered by existing Regexp strings:"
					sayerrq "Original input string: s="&remain
					sayerrq "Remaining string: remain="&remain

				End If
			End If

		Else					' Splitmark unknown (not handled above). Just append and continue
			saydbgq "@argsubst Unknown splitmark found: /result/splitmark/leftstr/remain/ = /" & result & "/" & splitmark & "/" & leftstr & "/" & remain & "/"
			result = result & splitmark
			remain = Mid(remain, 2)		' remove splitmark from remaining string
		End If

		'remain = Mid(remain, 2)
		If result = result0 And remain = remain0 Then
			stagCount = stagCount + 1
		Else
			stagCount = 0
		End If

		if stagCount > 2 Then
			sayerr "Error (argsubst): Loop NOT making progress: result = '" & result & "'"
			sayerr "remain = '" & remain & "'"
			Exit Do		' #### DEBUG
		End If


		i=i+1						' #### DEBUG
		if i > 12 Then
			sayerr "Error (argsubst): Loop count exceeded, i = " & i
			Exit Do		' #### DEBUG
		End If
		result0 = result
		remain0 = remain
	Loop
	
	result = """" & result & """"
	saydbgq   "@argsubst Returning: result="&result

	argsubst = result
End Function ' Function argsubst(s)
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O

'! Call argsubst and then remove the enclosing quotes (first and last char) from the result
Function argsubs2 (ByRef s)
	argsubs2 = argsubst (s)
	argsubs2 = Mid(argsubs2, 2)
	argsubs2 = Left(argsubs2, Len (argsubs2) - 1)
End Function ' Function argsubs2 (ByRef s)
}

' ====================================================================================================
' ====================================================================================================
' ====================================================================================================
'What I want:
' 1. If logfile not open eg. On starting test run:
' 	a.Create TClogFileName (jst take samename.tclog)
' 	b. Open the file for overwriting or appending (options to rename, append, overwrite)
'		Errors:
'		b1. invalid filename
'		b2. permission violation
'		b3. open failed, other reasons (could be a few)
' 	c. Write initial blurb: Date, Time, name of test object, params(?)
' 2. If logfile already open:
' 	a. Write current log result:
'		a1. Testcase number
'		a2. Testcase name
'		a3. Timestamp (options: each main TC, each sub-TC)
'		a4. Detail on what was tested (options: level of detail)
'		a5. Any comment texts, from TC file
'		a6. TC result: OK, Fail, other (?)
'		a7. Update statistics: TCokCount, TCfailCount, ...Count
'		a8. 
' 	b. For every write
'		b1. Turn Error checking on
'		b2. If error just quit the whole run: Write error could be:
'			b2a. File thought open but wasn't
'			b2b. Permission violation
'			bcc. Disk full
'			b2d. Other...
'		b3. Update housekeeping...
' 3. If at end of test run or chapter:
' 	a. Write out statistics 
' 	d. End and close
 
' ====================================================================================================
{ Sub TCwriteLogFile (ByRef filePath, ByRef s)
	Const ForReading = 1, ForWriting = 2, ForAppending = 8
	Dim fso, sh, file, fileText, dir
	Dim i, k
	writeHistoryFile = ""

	if filePath = "" then
		sayerr "Error (TCwriteLogFile): FileName not defined."
		exit Sub
	end if

	Set fso = CreateObject("Scripting.FileSystemObject")
	Set file = fso.OpenTextFile(filePath, ForAppending, True)

	file.writeLine(s)
	
	file.Close
	Set fso = Nothing

end Sub ' Sub TCwriteLogFile ()
}


 '_h2 TCNew (s) - Start New TestCase: Reset relevant bookkeeping vars and announce in log output
 ' ====================================================================================================
{ Sub TCNew (s)
	Dim myLocVar1
	' Decode opts and args
	sArr = Split (Trim(s), " ", 2)
	myLocVar1 = "Inside Sub TCNew, called with s='" & s & "'"

	' The following does not display as intended because myLocVar1 is local
	' TClog replace_args ("TCNew saying myLocVar1:{myLocVar1}")
	'. say TCNew saying myLocVar1:{myLocVar1}
    '. say TCNew saying myLocVar1:{myLocVar1}

	' Close and reopen TClogfile for each new TestCase (Only one TC worth of log output is lost in case of error)


	' Set data, Note these vars are all global, reflecting current test case and sub-case
	TCnum		= sArr(0)
	TCtitle		= sArr(1)
	TCsubNum	= 0
	TCtitle2	= ""

	' Log what's going on
	TClog ""
	TClog replace_args ("TestCase: {TCnum} {TCtitle}")
	TClog "===================================================================================================="
End Sub ' Sub TCNew (s)
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
}

' ====+====1====+====2====+====3====+====4====+====5====+====6====+====7====+====8====+====9====+====0	


{
'_h2 TClog (s) - Write to TC log output ie. stdout and any outfiles defined
' ====================================================================================================
' TODO: Outfiles NIY, Also: control verbosity level with global variables
Sub TClog (s)
	say s
	If oTClogFile Is Nothing Then
		' sayerr "Warning (TClog): Unable to write to logfile. No log file open"
	Else 
		oTClogFile.WriteLine(s)
	End If
End Sub ' Sub TClog (s)

Sub TCcheckResult (ByRef line, ByRef expected)
	Dim caption: caption = ""
	TCcheckSubResult caption, line, expected
End Sub ' ...
}


'_h2 TCcheckSubResult (caption, line, expected) - Check result of TestCase, update bookkeeping and write log outputs
' ====================================================================================================
	'!@TODO Todo: Sub TCcheckSubResult (caption, line, expected)
	'! Options to:
	'!	o -i Ignorecase (default is false)
	'!	o (Default): Remove the matched pattern (in case it matched)
	'!	o -R Do NOT Remove anything
	'!	o -l Remove the line where the matched pattern was found
	'!	o Remove from beginning up to the matched pattern
	'!	o Remove from beginning up to end of line where pattern found
	'!	o 
	'!	o 

{ Sub TCcheckSubResult (ByRef caption, ByRef line, ByRef expected)

	' Preparation
	saydbg "@tcsubresult enter"			' **** DEBUG
	TCsubNum = TCsubNum + 1

	If oTCregx is Nothing then
		Set oTCregx = New RegExp
		oTCregx.global = false
		oTCregx.ignorecase = false
	End If

'	oTCregx.pattern = "(" & expected & ")([\s\S]*)"
	oTCregx.pattern = expected
	saydbg "@TCcheckResult|tcsubresult about to execute pattern:" & "(" & expected & ")([\s\S]*)"			' **** DEBUG

	saydbgq "@TCcheckResult|tcsubresult Comapring Expected:" & expected
	saydbgq "@TCcheckResult|tcsubresult To actual line    :" & line

	Set oTCmatch = oTCregx.Execute(line)

	
	'	saydbg "@TCcheckResult|tcsubresult Now checking if matched or not"			' **** DEBUG
	' Now check if it matched or not
	' If oTCmatch.Count > 0 Then
	If oTCregx.Test(line) Then
		TCsuccess = True
		iTCTotCount  = iTCTotCount  + 1
		iTCFailCount = iTCFailCount + 1
		' Set TCremain to the (.*) part
		'max = oTCmatch(0).submatches.Count-1
		'TCremain = oTCmatch(0).submatches(max)
		TCremain = oTCregx.Replace (line, "")
		line = TCremain
	# If dbg_ontopic ("tcsubresult") <> "" Then dbg "add argsubst"
		'TCcheckMessage = argsubs2 ("==== Result: TC-$TCnum $caption OK")
		'TClog argsubs2 ("==== Result: TC-$TCnum $caption OK")
		'. TCcheckMessage= ==== Result: TC-$TCnum $caption OK
		'. TCcheckMessage= ==== Result OK: TC-$TCnum.$TCsubNum $caption
		. TCcheckMessage= ==== Result OK: TC-$TCnum.$TCsubNum $caption
	# If dbg_ontopic ("tcsubresult") <> "" Then dbg "del argsubst"
		TClog TCcheckMessage
	Else
		TCsuccess = False
		iTCTotCount  = iTCTotCount  + 1
		iTCFailCount = iTCFailCount + 1
	# If dbg_ontopic ("tcsubresult") <> "" Then dbg "add argsubst"
		'TClog argsubs2 ("==== Result: TC-$TCnum $caption #### FAILED ####")
		'. TCcheckMessage= ==== Result: TC-$TCnum $caption #### FAILED ####
		. TCcheckMessage= #### FAILED ####: TC-$TCnum.$TCsubNum $caption
	# If dbg_ontopic ("tcsubresult") <> "" Then dbg "del argsubst"
		TClog TCcheckMessage

	End If
 End Sub ' Sub TCcheckSubResult (ByRef caption, ByRef line, ByRef expected)
}

' =================================================================================================
{ Private Sub RunTest(ByVal filename)
	' take filename as input
	'		extension .vbst is added unless given
	'		other extensions (dot anywhere in filename) are preserved
	'		filename. overrides: dot is removed and no extension used
	' log file is filename.log
	'		TODO: nifty way to specify other extensions eg. .vbstlog
	'		Initial test stamp logged: Date filename etc. 
	'		previous logfile is overwritten
	'		TODO: option to rename previous logfile
	'		TODO: option to append to logfile instead
	'		logfile is closed and reopened for append for each new TestCase to minimise loss on deadlock or error
	'		log output is flushed continuously on every write
	'		TODO: options for summary/normal/detailed log output
	'				detailed: 	- Initial presentation blurb for each test case
	'							- "comment" log commands eg. "setting up for test xyz"
	'							- all sent setup commands are logged (eg. setting memory)
	'							- all setup output received back (confirmations activated if present)
	'							- sent test commands are logged
	'							- stepwise execution with logging defined at each step
	'							- "misc" detailed schemes yet to be thought of
	'							- all test output received back
	'							- all test results 
	'							- all output/lookfor comparisons on failure
	'				normal: 	- Initial presentation blurb for each test case
	'							- "comment" log commands eg. "setting up for test xyz"
	'							- NOT all sent setup commands are logged (eg. setting memory)
	'							- NOT all setup output received back (confirmations activated if present)
	'							- all sent test commands are logged
	'							- NOT (probably) stepwise execution with logging defined at each step
	'							- NOT (probably) "misc" detailed schemes yet to be thought of
	'							- all test output received back
	'							- all test results 
	'							- all output/lookfor comparisons on failure
	'				summary: 	- NO Initial presentation blurb for each test case
	'							- Possibly test section logs ie. log starting in on new chapter 
	'							- NOT all "comment" log commands 
	'							- NOT all sent setup commands are logged (eg. setting memory)
	'							- NOT all setup output received back (confirmations activated if present)
	'							- NOT all sent test commands are logged
	'							- NOT (probably) stepwise execution with logging defined at each step
	'							- NOT (probably) "misc" detailed schemes yet to be thought of
	'							- NOT all test output received back
	'							- All test results with 
	'							- NOT all output/lookfor comparisons on failure
	'				normal:		- 
	'				
	'				
	' console output:
	'		Complete text seen, same as logfile
	'		TODO: options for summary/normal/detailed console output
	' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
	Const ForReading = 1, ForWriting = 2, ForAppending = 8
	Dim testFileName, logFileName, testfnamepart, testfbasenamepart, testflogext, testDirPath

	'!@Todo: Testfile in current dir by default (not much sense in searching for it in env:PATH)
	'!@Todo: Logfile in current dir by default, even if Testfile is not. option to send it to dir of testfile
	testflogext = "log"

	' Get fullpath of input file and logfile:

	TCfileName = findFileName(Trim(filename))

	If Trim (TCfileName) = "" Then
		. sayerr Error (RunTest): File $filename Not found.
		Exit Sub
	End If

	testFNamepart = GoFS.GetFileName (TCfileName)
	testFBaseNamepart = GoFS.GetBaseName (TCfileName)
	testDirPath = Left(TCfileName, Len (TCfileName) - Len (testfnamepart))
	TClogFileName = testDirPath & testFBaseNamepart & "." & testflogext

	saydbg "@runtest TCfileName    : " & TCfileName
	saydbg "@runtest TClogFileName : " & TClogFileName
	' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
	' Open oTClogFile
	' Todo: if old logfiles present, choose between: overwrite, append, rename

	Set oTClogFile = GoFS.OpenTextFile (TClogFileName, ForWriting, True )
	'If Err Then Errorhandling...
	
	. TClog $ProgNameString, Running Test File on: $date $time
	. TClog TCfileName    : $TCfileName
	. TClog TClogFileName : $TClogFileName
	'TClog ""

	runTestFile TCfileName

	' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
	'Cleanup
	oTClogFile.Close
	Set oTClogFile = Nothing

End Sub ' Private Sub RunTest(ByVal filename)
}

Set rtest=GetRef ("RunTest")

{ Sub docit (fname)
	' Extract fname into _full, _path, _stem, _extension
	fname = Trim(GoSh.ExpandEnvironmentStrings(fname))
	If InStr(fname, ".") = 0 then
		fbasename = fname
		If GoFs.FileExists(fbasename & ".vbs") Then
			fname = (fname & ".vbs")
		ElseIf GoFs.FileExists(fbasename & ".vbsx") Then
			fname = (fname & ".vbsx")
		ElseIf GoFs.FileExists(fbasename & ".vbst") Then
			fname = (fname & ".vbst")
		End If
	End If

	fbasename = GoFs.GetBaseName(fname)

	If Not GoFs.FileExists(fname) Then
		sayerr "Error (docit), File not found: " & fname
		Exit Sub
	End If

	. say command to run: cscript.exe //NoLogo VBSdoc_hs.vbs /q /a /i:$fname /o:./docs/$fname

	. saydos cscript.exe //NoLogo VBSdoc_hs.vbs /q /a /i:$fname /o:./docs/$fname
End Sub
}
	
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
' Class SlaveInterface
' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
'
' If SlaveInterface_Defined Then GlobalDiscardNextBlock = True
' SlaveInterface_Defined = True

#.say Testing: Hashmark syntax working outside curly-block, or not?

{ 
 #.say Testing: Hashmark syntax working in curly-block, or not?
 # If SlaveInterface_Defined Then GlobalDiscardThisBlock = True
 # If SlaveInterface_Defined Then sayerr "Skipping: Class SlaveInterface already defined"
 # SlaveInterface_Defined = True

 #.say ##############  (Experimental) HASHmark Subsitution ################


Class SlaveInterface

	' Default Parameters
	Public ESlvIn_Dfl, LSlvIn_Dfl, ESlvOut_Dfl, LSlvOut_Dfl, LWarn_Dfl
	Public ESlvInMark_Dfl, LSlvInMark_Dfl, ESlvOutMark_Dfl, LSlvOutMark_Dfl

	' Current Parameters
	Public ESlvIn, LSlvIn, ESlvOut, LSlvOut, LWarn
	Public ESlvInMark, LSlvInMark, ESlvOutMark, LSlvOutMark

	' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
	Private Sub Class_Initialize ()

		' Parameters to control sending, receiving and logging of text between master and slave processes
		' Note: The _initial_ default values are set here, but they may be changed later by command
			' Variable:		Default:	  Long-Name:		Set by what Options:			  Description:

			' Variable:		Default:  Long-Name:			Set by what Options:			  Description:
			ESlvIn_Dfl		= False	' EchoSlaveInput,		-i -I	: True, False (default)	- Echo text to console, before sending it to slave stdin
			LSlvIn_Dfl		= False	' LogSlaveInput,		-s -S*	: True, False (default) - Write text to logfile, before sending it to slave stdin
			ESlvOut_Dfl		= True	' EchoSlaveOutput,		-o -O	: True (default), False - Echo to console: text coming back from slave stdout
			LSlvOut_Dfl		= True	' LogSlaveOutput,		-l -L*	: True (default), False - Write to logfile: text coming back from slave stdout
			LWarn_Dfl		= False	' TCLogWarning,			-w -W*	: True, False (default)	- Warning to console if unable to log due to logfile not open
			ESlvInMark_Dfl	= "=>"	' EchoSlaveInpMarker,	-f -F**	: "=>" is default		- Mark to identify text echoed to console before sending to slave stdin
			LSlvInMark_Dfl	= "=>"	' LogSlaveInpMarker,	-g -F**	: "=>" is default		- Mark to identify text written to logfile before sending to slave stdin
			ESlvOutMark_Dfl	= ">"	' EchoSlaveOutputMarker	-b -B**	: ">" is default		- Mark to identify text echoed to console, received back from slave stdout
			LSlvOutMark_Dfl	= ">"	' LogSlaveOutputMarker	-c -B**	: ">" is default		- Mark to identify text written to logfile, received back from slave stdout
			' *  Note: Explicitly given -s or -l imply -w, and in that case explicit -W is required to disable warnings
			' ** Note: -F combines -fg, -B combines -bc
			' Other options: -d - apply current options as global defaults (can be given without a cmdline proper)
			' Error exit if contradictory options entered
			' Note also: possibility to go into "direct-slave mode", ie.
			' all input and output goes directly to slave and back, plus an
			' escape command to bring us back to normal.
			' logging input or output to file or both can be on while in direct mode,
			' even with individual input/output markers, different from the ones
			' seen on the console
			setDefaultParams ()		' Set parameters to their initial default values


		' Next item ...

	end Sub ' Private Sub Class_Initialize ()

	Private Sub Class_Terminate ()
		' Write pending buffers (?)
		' Close open file(s)
	End Sub ' Private Sub Class_Destroy ()


	Public Default Function Init(s)
		Set Init = Me
	End Function

	' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
	Private Sub setDefaultParams ()
		' Set parameters to their _current_ default values (each described above in Class_Initialize)
		' Note: The initial default values set in Class_Inizialize on class object creation
		'		may have been changed later by command.
		'		Ie. _initial_ and _current_ defaults are not necessarily the same
		ESlvIn			= ESlvIn_Dfl
		LSlvIn			= LSlvIn_Dfl
		ESlvOut			= ESlvOut_Dfl
		LSlvOut			= LSlvOut_Dfl
		LWarn			= LWarn_Dfl
		ESlvInMark		= ESlvInMark_Dfl
		LSlvInMark		= LSlvInMark_Dfl
		ESlvOutMark		= ESlvOutMark_Dfl
		LSlvOutMark		= LSlvOutMark_Dfl
		
	End Sub

	' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
	Public Sub sayParams ()
		' Print out all parameters and their current values
		%psaywtype ESlvIn		
		%psaywtype LSlvIn		
		%psaywtype ESlvOut		
		%psaywtype LSlvOut		
		%psaywtype LWarn		
		%psaywtype ESlvInMark	
		%psaywtype LSlvInMark	
		%psaywtype ESlvOutMark	
		%psaywtype LSlvOutMark	
	End Sub



	' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
	Sub ssend (ByRef cmdline)
		'! Usage: ssend -E -l <line>
		'!@param -i EchoSlaveInput = True, (False is default)	- Echo text to console, before sending it to slave stdin
		'!@param -I EchoSlaveInput = False (default)			- Echo nothing to console, send text silently to slave stdin
		'! conboseSend console-verbose = verbose output to console on send
		'! logboseSend logfile-verbose = verbose output to logfile on send
		'!@param -v - Verbose on (off is default) Echo <line> just before sending it
		'!@param -l - Logging on (off is default) Echo <line> just before sending it

		' Options: 
			' Variable:			Default:  Long-Name:			Set by what Options:			  Description:
			' ESlvIn_Dfl		= False	' EchoSlaveInput,		-i -I	: True, False (default)	- Echo text to console, before sending it to slave stdin
			' LSlvIn_Dfl		= False	' LogSlaveInput,		-s -S*	: True, False (default) - Write text to logfile, before sending it to slave stdin
			' ESlvOut_Dfl		= True	' EchoSlaveOutput,		-o -O	: True (default), False - Echo to console: text coming back from slave stdout
			' LSlvOut_Dfl		= True	' LogSlaveOutput,		-l -L*	: True (default), False - Write to logfile: text coming back from slave stdout
			' LWarn_Dfl			= False	' TCLogWarning,			-w -W*	: True, False (default)	- Warning to console if unable to log due to logfile not open
			' ESlvInMark_Dfl	= "=>"	' EchoSlaveInpMarker,	-f -F**	: "=>" is default		- Mark to identify text echoed to console before sending to slave stdin
			' LSlvInMark_Dfl	= "=>"	' LogSlaveInpMarker,	-g -F**	: "=>" is default		- Mark to identify text written to logfile before sending to slave stdin
			' ESlvOutMark_Dfl	= ">"	' EchoSlaveOutputMarker	-b -B**	: ">" is default		- Mark to identify text echoed to console, received back from slave stdout
			' LSlvOutMark_Dfl	= ">"	' LogSlaveOutputMarker	-c -B**	: ">" is default		- Mark to identify text written to logfile, received back from slave stdout
			' *  Note: Explicitly given -s or -l imply -w, and in that case explicit -W is required to disable warnings
			' ** Note: -F combines -fg, -B combines -bc
			' Other options: -d - apply current options as global defaults (can be given without a cmdline proper)
		' Other options: -d - apply current options as global defaults (can be given without a cmdline proper)
		' Error exit if contradictory options entered
		' Note also: possibility to go into "direct-slave mode", ie.
		' all input and output goes directly to slave and back, plus an
		' escape command to bring us back to normal

		Dim opts, opt_echo, opt_log, opts_allowed, clashMap, clash
		opts_allowed	= "diIsSoOlLwWF:f:g:B:b:c:"
		clashMap	= "iI, sS, oO, lL, wW, Ffg, Bbc"	' Map to detect "clashes" ie. conflicting options
		opts = ""
		' setDefaultParams ()		' Set parameters to their initial default values

		. saydbgq @ssend calling getopts with $opts_allowed, cmdline=$cmdline
		getopts opts_allowed, cmdline, opts
		. saydbgq @ssend after calling getopts, opts=$opts
		
		'opt_echo	=  True: If find_opt("E", opts) then opt_echo	= False
		'opt_log		= False: If find_opt("l", opts) then opt_log	= True

		' ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----O
		' Check for contradicting options
		clash = opt_sgClashCsv (clashMap, opts)
		If Not clash = "" Then
			sayerr "Error (SlaveInterface.ssend): conflicting options. -" _
			& Mid(clash,1,1) & " conflicts with -" & Mid(clash,2)
			Exit Sub
		End If


		. saydbgq @ssend End of current code. Showing params:
		sayparams


		Exit Sub
		' =================== DEAD CODE - UNDER CONSTRUCTION ===========================




		if SlaveExec Is Nothing then
			sayerr "Error: No slave app to send to."
			Exit Sub
		End If
		if opt_log Then TClog "(ssend) Sending: " & cmdline
		
		saydbg "@ssend Sending: " & cmdline
		SlaveExec.StdIn.WriteLine(cmdline)
		FoundLine = SlveReadUpto (SlavePrompt)
		if opt_echo And len(FoundLine) > 0 Then
			oRx.global = true
			' oRx.ignorecase = false		' not needed
			oRx.pattern = VBCrLf&"|\n"
				TClog SlaveOutFlag & oRx.Replace (FoundLine, VBCrLf & SlaveOutFlag)
	'			say SlaveOutFlag & oRx.Replace (FoundLine, VBCrLf & SlaveOutFlag)
		End If

	End Sub ' ssend(cmdline)

End Class ' SlaveInterface

sub tellus ()
	say version
end sub


}

