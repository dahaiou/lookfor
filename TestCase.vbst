
IncludeName = "TestCase.vbst"
IncludeVersion = "0.07-01"
inc1NameString = IncludeName & " V" & IncludeVersion
say "Including: " & inc1NameString

' ====================================================================================================
'_h1 TC - TestCase functions (for automated testing run from .vbst files)
' ====================================================================================================
'_h2 TC TestCase function globals
' ====================================================================================================
Dim TCnum			: TCnum				= 0			'! Testcase number eg. 1.3.7
Dim TCtitle			: TCtitle			= 0			'! Testcase title (name)
Dim TCsubNum		: TCsubNum			= 0			'! sub-Testcase number (plain number 1..n)
Dim TCsubTitle		: TCsubTitle		= ""		'! sub-Testcase title (name)
Dim bTCsendLogOn	: bTCsendLogOn		= False		'! bool: Log every command sent to Slave app on/off
Dim bTCechoOn		: bTCechoOn			= False		'! bool: Echo on/off
Dim bTCpass			: bTCpass			= False		'! bool: Testcase passed OK yes/no
Dim sTCexpected		: sTCexpected		= ""		'! Expected string (regex)
Dim sTCremain		: sTCremain			= ""		'! Remaining string

Dim TCtotCount		: TCtotCount  		= 0			'! Count of Testcases Executed or attempted
Dim TCpassCount		: TCpassCount 		= 0			'! Count of Testcases Passed OK
Dim TCfailCount		: TCfailCount	 	= 0			'! Count of Testcases Failed
Dim TCSubTotCount	: TCsubTotCount  	= 0			'! Count of sub-Testcases Executed or attempted
Dim TCsubPassCount	: TCsubPassCount 	= 0			'! Count of sub-Testcases Passed OK
Dim TCsubFailCount	: TCsubFailCount 	= 0			'! Count of sub-Testcases Failed

Dim oTCfs			: Set oTCfs			= Nothing	'! object: FileSystem object for manipulating TC log files
Dim oTClogFile		: Set oTClogFile	= Nothing	'! TC log file (single one, if not using array of logfiles)
Dim TCfileName		: TCfileName		= ""		'! Name of Test File being executed
Dim TClogFileName	: TClogFileName		= ""		'! Name of Logfile being written to


ReDim aTClogFiles (4)								'! array: open TClogFiles (not sure if needed)
Dim   TClogFilesCount	: TClogFilesCount = 0		'! Count of open TClogFiles  (not sure if needed)


 Dim oTCregx, oTCmatch
 Set oTCregx  = Nothing
 Set oTCmatch = Nothing

<:

 If Not TypeName (oTCfs) = "FileSystemObject" Then
	set oTCfs = Nothing
	set oTCfs = CreateObject("Scripting.FileSystemObject")
 End If
:>

 <:

 '! Open TestCase Logfile
 Sub TCopenLogFile (fname)
	' Handle opts: -a append, -r rename (earlier logfiles)...
	' Open logfile
	' Additional housekeeping to activate logging, if any
 End Sub

 '! Close TestCase Logfile and Shell
 Sub TCcloseLogFile (n)
	' Handle opts: ...
	' Close the files
	' Release the objects
	' Additional housekeeping if any
End Sub

'!@ref Tom Laveda 2003, http://computer-programming-forum.com/59-vbscript/bc9ef89b8cb2b879.htm
Function dos (DOSCmd)
  Dim alines, sCmd, stemp, ofs, oWS
  On Error Resume Next
  '  sCmd = """%comspec%"" /c ""%comspec%"" /e:4096 /c " & DOSCmd & " >"
  sCmd = "cmd.exe /c cmd.exe /e:4096 /c " & DOSCmd & " >"
  set ofs = CreateObject("Scripting.FileSystemObject")
  stemp = ofs.GetTempName
  set oWS = CreateObject("Wscript.Shell")
  stemp = oWS.Environment("PROCESS")("TEMP") & "\" & stemp
  'sTemp = "dos.tmp"		' #### DEBUG
  'sayerr "#### Running: oWS.Run " & sCmd & Chr(34) & sTemp & Chr(34) & " 2>&1, 0, true"		' #### DEBUG
  oWS.Run sCmd & Chr(34) & sTemp & Chr(34) & " 2>&1", 0, true

  ' The Original function MSDOS splits each line of outupt into the array alines
  ' alines = Split(ofs.OpenTextFile(stemp).ReadAll, vbNewline)
  ' ReDim Preserve alines(Ubound(alines) - 1)
  ' if Err Then aLines = Split(Empty)

  ' Here, we just return the output directly as a multiline string
  dos = ofs.OpenTextFile(stemp).ReadAll
  ofs.DeleteFile stemp
  if Err Then sayerr "DOS Error"	' This seems to have no effect after redirecting dos errout to stdout

  ' Dirty hack: Fix chr(255) which plagues redirected dos output due to codepage differences
  dos = Replace(dos,chr(255)," ")	
End Function 

Sub saydos (s)
	say dos(s)
End Sub

:>

<:
Private oRxSSubst 		: Set oRxSSubst 	= NewRegExp("\${([a-zA-Z]\w*)}|\$([a-zA-Z]\w*)", 	True, True)
Private oRxCurlySubst 	: Set oRxCurlySubst = NewRegExp("{([^}]*)}([\s\S]*)$|{([\s\S]*)$", 		True, True)
Private oRxShSubst 		: Set oRxShSubst 	= NewRegExp("\%{(\w+)}|\%(\w+)%?", 					True, True)
Function ssubst (s)
	'Substitute variables in a string. Example, the string:
	'	"It is now $time and $linecount lines have been read so far"
	' Is turned into:
	'	"It is now " & time & " and " & linecount & " lines have been read so far"
	Dim argstr, remain
	argstr = ""
	remain = ""

	'Gosh.ExpandEnvironmentStrings("%PATH%")
	oRxSSubst.Global = True
	ssubst = oRxSSubst.Replace(s, """ & $1$2 & """)
	oRxShSubst.Global = True
	ssubst = oRxShSubst.Replace(ssubst, """ & Gosh.ExpandEnvironmentStrings(""%$1$2%"")  & """)
	'First case: s did not have initial quote but ssubst does.
	'	This means s began with a $substitution and we must supply another initial quote for things to work
	if Not Left(rxLtrim(s),1) = """" And Left(rxLtrim(ssubst),1) = """" Then ssubst = """" & ssubst
	'Second case: s ended with a $substitution and we must supply an extra quote at the end
	if Not Right(rxRtrim(s),1) = """" And Right(rxLtrim(ssubst),1) = """" Then ssubst = ssubst & """"

	'Third case: Supply initial quote if not present.
	if Not Left(rxLtrim(ssubst),1) = """" Then ssubst = """" & ssubst
	'Fourth case: Supply final quote if not present
	if Not Right(rxRtrim(ssubst),1) = """" Then ssubst = ssubst & """"
End Function ' Function ssubst (s)

'Private oRxIniPunct : Set oRxIniPunct = NewRegExp("^[^\S\n]*[,.;:_\\\|\@\#\~!$%&=?+-*/]", True, True)
Private oRxIniPunct : Set oRxIniPunct = NewRegExp("^[^\S\n]*[,.;:_\\\|\@\#\~!$%&=?\+\-\*\/]", True, True)
Private oRxIniToken : Set oRxIniToken = NewRegExp("^([^\S\n]*[a-zA-Z]\w*)([\s\S]*)$", True, True)
Function cmdsubst (ByRef s)
	Dim token, argstr, remain
	token = ""
	argstr = ""
	remain = ""

	' Remove initial (only one) punctuation character, any of ",.;:_\|@#~!"·$%&=?¿+-*/"
	remain = oRxIniPunct.Replace (s, "")
	If oRxIniToken.Test (remain) Then
		token  = oRxIniToken.Replace (remain, "$1")
		remain = oRxIniToken.Replace (remain, "$2")
	End If
	If Left(remain,1) = " " Then remain = Mid(remain, 2)		' Remove one initial space if present

	'While Not remain = ""

	'Wend
	



	'remain = ssubst(remain)
	remain = argsubst(remain)

	'sayq "token="&token
	'sayq "remain="&remain

	cmdsubst = token & " " & remain

End Function ' Function cmdsubst (s)

:>


Private oRxSplitmark	: Set oRxSplitmark 		= NewRegExp("^([^\$\%\{\""]*)([\s\S]*)$", 	True, False)
Private oRxSplitDquote	: Set oRxSplitDquote 	= NewRegExp("^([^""]*)([\s\S]*)$", 			True, False)
Private oRxRightCurly	: Set oRxRightCurly 	= NewRegExp("^([^}]*)([\s\S]*)$", 			True, False)

Private oRxCurlyMissing	: Set oRxCurlyMissing 	= NewRegExp("^\s*{?([^}]*)$",	 			True, False)
Private oRxCurlyEmpty	: Set oRxCurlyEmpty 	= NewRegExp("^\s*{?(\s*)}([\s\S]*)$",		True, False)
Private oRxCurlyNormal	: Set oRxCurlyNormal 	= NewRegExp("^\s*{?([^}]*)}([\s\S]*)$",		True, False)

{ Function argsubst(ByRef s)
	Dim result, leftstr, remain, state
	result = ""
	leftstr = ""
	remain = s
	state = 0		' 0=normal, 1=doublequote, 2=singlequote, 3=curly, 4=dollar, 5=percent, 

	i=0
	Do While Not remain = ""
		'say "=============================="
		'sayq "remain="&remain
		leftstr = oRxSplitmark.Replace(remain, "$1")
		remain  = oRxSplitmark.Replace(remain, "$2")
		
		'sayq "result="&result
		'sayq "leftstr="&leftstr
		'sayq "remain="&remain
		splitmark=Left(remain, 1)
		'say  "splitmark="&splitmark

		' pass the "normal text" in leftstr to the "left side" ie. append it to result
		' NOTE: In some special cases the last character is removed in the logic below
		result = result & leftstr		
										

		' "escaped" splitmark found ie. it does not count
		' just pass the splitmark to the "left side" ie. append it to result	
		'!@Todo It is NOT possible to have a literal backslash just before a splitmark.
		'!		It could be solved by requiring double backslash, but this is not really acceptable
		'!		since you sometimes need backslashes galore in DOS-style filepaths
		'!		Or doubling them just in the special case where followed by a splitmark, which is a dirty workaround
		'!		So we want "text1\text2\text3\etc" handled as "normal text" ie. appended as-is
		'!		But also "text1\$text2" to be appended as "text1$text2"
		'!		and as a workaround, "text1\\$text2" as "text1\$text2"
		'!		But then if we should want "text1\$var1" appended with var1 substituted it simply can't be done
		'!		Solution: use ^ as an escape cancellation character, removed if found prior to a splitmark char.
		'!			... then "text1\^$var1" appends "text1\" & var1 & " with var1 substituted
		'!			NOW. if you DO want up-arrow in that position, it just needs to be doubled
		'!			so "text1\^^$var1" appends "text1\^" & var1 & " ie. including ^ up-arrow and with var1 substituted
		If Right(result,2) = "^" Then
			' Remove the escape-cancellation character ^ (but if it was doubled ^^ the first one is left in)
			result = Left(result,len(result - 1))
		End If

		' NOTE: For escape-cancellation to work it is IMPORTANT to check end of leftstr here, not of result, 
		If Right(leftstr,1) = "\" Then
			' first remove the escape-mark (backslash) from end of result
			' then append the splitmark as-is
			result = Left(result,len(result - 1)) & splitmark
			remain = Mid(remain, 2)		' remove splitmark from remaining string
	
		ElseIf splitmark = """" Then	' Handle double-quote substring
			result = result & """"""	' "double" the double-quote and append to result
			'sayq "at start of quote, result="&result
			remain = Mid(remain, 2)		' remove splitmark from remaining string
			' Find closing double-quote
			leftstr = oRxSplitDquote.Replace(remain, "$1")
			remain = oRxSplitDquote.Replace(remain, "$2")
			result = result & leftstr & """"""		' Append quoted string closed with doubled close-quote
			'sayq "at end of quote, result="&result
			remain = Mid(remain, 2)		' remove close-quote from remaining string
	
		ElseIf splitmark = "'" Then	'Handle single-quote ie. comment string until eol
			remain = ""			' Empty remain will cause immediate exit from loop
								' NOTE: multi-line input not handled here. If so we need to delete only to eol and continue

		ElseIf splitmark = "$" Then	'Handle $varname and ${varname}
			' Extract the first $variable substitution from remain
			' The logic below depends on knowing the fact that the first substitution begins in position 1
			' and after substitution the first double-quote will be in char position 1
			oRxSSubst.Global = False
			remain = oRxSSubst.Replace(remain, """ & $1$2 & """)	' Do just one $substitution (at pos 1 in remain)
			qpos = InStr(2, remain, """")			' Find pos of second quote char (we know first one is in pos 1 )
			'sayq "$substitution done, remain="&remain
			result = result + Left(remain, qpos)	' append the variable substitution to result
			remain = Mid(remain, qpos + 1)			' and remove it from the beginning of remaining str
			'sayq "...and remaining remain="&remain

		ElseIf splitmark = "%" Then	'Handle %varname, %varname%, %{varname}
			' Extract the first %variable substitution from remain
			' The logic below depends on knowing the fact that the first substitution begins in position 1
			' and after substitution the first double-quote will be in char position 1
			oRxShSubst.Global = False
			' Do just one $substitution (at pos 1 in remain)
			remain = oRxShSubst.Replace(remain, """ & Gosh.ExpandEnvironmentStrings(""%$1$2%"")  & """)
			qpos = InStr(2, remain, ")")			' First right bracket (we know the quote char we want comes right after that )
			qpos = InStr(qpos, remain, """")		' Find pos of the final quote char at end of substitution
			'sayq "%substitution done, remain="&remain
			result = result + Left(remain, qpos)	' append the variable substitution to result
			remain = Mid(remain, qpos + 1)			' and remove it from the beginning of remaining str
			'sayq "...and remaining remain="&remain

		ElseIf splitmark = "{" Then	'Handle curly-brace expression {expr}

			Subst1   = oRxCurlySubst.Replace(remain, "$1")
			Subst2   = oRxCurlySubst.Replace(remain, "$2")
			Subst3   = oRxCurlySubst.Replace(remain, "$3")

			If oRxCurlyMissing.Test(remain)  Then
				sayerr "Error: Closing curly-brace missing in line ..."
				leftstr = ""
				remain = Mid(remain, 2)		' remove opening curly-brace from remaining string
				sayq "remain="&remain
				
			ElseIf oRxCurlyEmpty.Test(remain)  Then
				leftstr = ""
				remain  = oRxCurlyEmpty.Replace (remain, "$2")
				say  "Whitespace or empty string withing curly-braces"
				sayq "remain="&remain

			ElseIf oRxCurlyNormal.Test(remain)  Then
				leftstr = oRxCurlyNormal.Replace (remain, "$1")
				remain  = oRxCurlyNormal.Replace (remain, "$2")

				' TODO: Test with: a. curly not closed b. curly at end of line c. curly empty {}
				say  "==== about to ExecuteGlobal:"
				sayq "leftstr="&leftstr
				sayq "remain="&remain

				' Now globalexecute the expression found inside the curly braces

				strictErrExit = False
				On Error Resume Next
				Err.Clear
				'say "ExecuteGlobal (""GsubstVar=""&trim("&leftstr&"))"		' *** DEBUG
				'ExecuteGlobal "GsubstVar="&trim(leftstr)
				' sayq "about to ExecuteGlobal: GsubstVar="""" & "&trim(leftstr)
				ExecuteGlobal "GsubstVar="""" & "&trim(leftstr)
				' GsubstVar = Eval(leftstr)
				If Err.Number <> 0 Then
					sayerr f_error & "Unable to substitute variable or expression: """ & trim(leftstr) & """"
					sayerr Trim(Err.Description & " (0x" & Hex(Err.Number) & ")")
					GsubstVar=""
					If strictErrExit Then		' strictErrExit means quit on first error leaving the whole line unparsed
						Exit Function
					Else 
						' GsubstVar="{" & s & "}" 	' putting the erroneous string back in was an experiment, but not a good idea.
						' This way {<invalid expression>} is just removed, including the curlies
					End If
				End If
				On Error Goto 0
				result = result & GsubstVar ' Append resulting string (leftstr still holds the original expression before execution)

			Else
				sayerr "Error: Internal logic failed. Case not covered by existing Regexp strings:"
				sayerrq "Remaining string: remain="&remain

			End If

		End If

		'remain = Mid(remain, 2)
		i=i+1						' #### DEBUG
		if i > 12 Then Exit Do		' #### DEBUG
	Loop
	
	result = """" & result & """"
	'sayq "result="&result
	argsubst = result
End Function ' Function argsubst(s)
}

{
 '! : Checking Global_sPipeClass_defined
 If Global_sPipeClass_defined Then
	sayerr "Warning: Class cannot be redefined. Skipping sPipeClass."
	GlobalDiscardNextBlock = True
	' wscript.sleep(500)
 End If
}   
 
'*wscript.sleep(100)
'*say "Just slept 100"
'If GlobalDiscardNextBlock Then say "GlobalDiscardNextBlock is True"

' Note, without the following line GlobalDiscardNextBlock does not work the first time through here
' 		Starting from the second time it works OK without
'If GlobalDiscardNextBlock Then dummy = 0

'If Global_sPipeClass_defined Then GlobalDiscardNextBlock = True
{   '<: 'sPipeClass
 ' '!: Silly String Pipe functions - NB: Initial '!: Generates "Direct" .vbst parse-time comment output
 '# If Global_sPipeClass_defined Then GlobalDiscardThisBlock = True
  Global_sPipeClass_defined = True

  '#.say ##############  Wonderful HASHmark Subsitution ################
 ' '!: Just about to declare sPipeClass - NB: Initial '!: Generates "Direct" .vbst parse-time comment output
 class sPipeClass
	Dim Subscribers()
	Dim SubsCount, sBuf

	Sub Write(s)
		' Do stuff
 	End Sub

	Sub Writeline(s)
		' Do stuff
	End Sub
	
	Function GetBuf()
		' Do stuff
	End Function
 	
 End Class

}

{sayerr "#### DEBUG INSIDE Curlies ..."
sayerr "#### Happy days with close token }" }

sayerr "#### DEBUG will this show ???"

sayerr "Still running after sPipeClass"

<:

' Prints the time at parse-time, ie. time when this code was read in
Sub saytime1()
 .say Current time1: {Time}
End Sub

' Prints the literal string "Current time1: {Time}" without substitution of {Time}
Sub saytime2()
 say "Current time1: {Time}"
End Sub

' Prints the current time when executed, 
Sub saytime3()
 say "Current time1: " & Time
End Sub

' Prints the current time when ??? 
Sub saytime4()
	a=ssubst ("Current time1: $Time")
	say a
End Sub


' ====================================================================================================
' ====================================================================================================
' ====================================================================================================
'What I want:
' 1. If logfile not open eg. On starting test run:
' 	a.Create TClogFileName (jst take samename.tclog)
' 	b. Open the file for overwriting or appending (options to rename, append, overwrite)
'		Errors:
'		b1. invalid filename
'		b2. permission violation
'		b3. open failed, other reasons (could be a few)
' 	c. Write initial blurb: Date, Time, name of test object, params(?)
' 2. If logfile already open:
' 	a. Write current log result:
'		a1. Testcase number
'		a2. Testcase name
'		a3. Timestamp (options: each main TC, each sub-TC)
'		a4. Detail on what was tested (options: level of detail)
'		a5. Any comment texts, from TC file
'		a6. TC result: OK, Fail, other (?)
'		a7. Update statistics: TCokCount, TCfailCount, ...Count
'		a8. 
' 	b. For every write
'		b1. Turn Error checking on
'		b2. If error just quit the whole run: Write error could be:
'			b2a. File thought open but wasn't
'			b2b. Permission violation
'			bcc. Disk full
'			b2d. Other...
'		b3. Update housekeeping...
' 3. If at end of test run or chapter:
' 	a. Write out statistics 
' 	d. End and close
 
' ====================================================================================================
Sub TCwriteLogFile (ByRef filePath, ByRef s)
	Const ForReading = 1, ForWriting = 2, ForAppending = 8
	Dim fso, sh, file, fileText, dir
	Dim i, k
	writeHistoryFile = ""

	if filePath = "" then
		sayerr "Error (TCwriteLogFile): FileName not defined."
		exit Sub
	end if

	Set fso = CreateObject("Scripting.FileSystemObject")
	Set file = fso.OpenTextFile(filePath, ForAppending, True)

	file.writeLine(s)
	
	file.Close
	Set fso = Nothing

end Sub ' Sub TCwriteLogFile ()
:>


<:
 '_h2 TCNew (s) - Start New TestCase: Reset relevant bookkeeping vars and announce in log output
 ' ====================================================================================================
Sub TCNew (s)

	' Decode opts and args
	sArr = Split (Trim(s), " ", 2)
	Dim myLocVar1
	myLocVar1 = "Inside Sub TCNew, called with s='" & s & "'"

	' The following does not display as intended because myLocVar1 is local
	' TClog replace_args ("TCNew saying myLocVar1:{myLocVar1}")
	'.say TCNew saying myLocVar1:{myLocVar1}
    '.say TCNew saying myLocVar1:{myLocVar1}

	' Close and reopen TClogfile for each new TestCase (Only one TC worth of log output is lost in case of error)


	' Set data, Note these vars are all global, reflecting current test case and sub-case
	TCnum     = sArr(0)
	TCtitle   = sArr(1)
	TCnumber2 = ""		' sub-number and -title
	TCtitle2  = ""

	' Log what's going on
	TClog ""
	TClog replace_args ("TestCase: {TCnum} {TCtitle}")
	TClog "===================================================================================================="
End Sub ' Sub TCNew (s)
:>
<:
'_h2 TClog (s) - Write to TC log output ie. stdout and any outfiles defined
' ====================================================================================================
' TODO: Outfiles NIY, Also: control verbosity level with global variables
Sub TClog (s)
	say s
	oTClogFile.WriteLine(s)
End Sub ' Sub TClog (s)

'_h2 TCcheckResult (line, expected) - Check result of TestCase, update bookkeeping and write log outputs
' ====================================================================================================
'!@TODO: ...
'! Options to:
'!		o -i Ignorecase (default is false)
'!		o (Default): Remove the matched pattern
'!		o -R Do NOT Remove anything
'!		o -l Remove the line where the matched pattern was found
'!		o Remove from beginning up to the matched pattern
'!		o Remove from beginning up to end of line where pattern found
'!		o 
'!		o 
Sub TCcheckResult (ByRef line, expected)
	' Preparation
	' saydbg "TCcheckResult enter"			' **** DEBUG
	If oTCregx is Nothing then
		Set oTCregx = New RegExp
		oTCregx.global = false
		oTCregx.ignorecase = false
	End If

'	oTCregx.pattern = "(" & expected & ")([\s\S]*)"
	oTCregx.pattern = expected
	'	saydbg "TCcheckResult about to execute pattern:" & "(" & expected & ")([\s\S]*)"			' **** DEBUG
	Set oTCmatch = oTCregx.Execute(line)

	
	'	saydbg "Now checking if matched or not"			' **** DEBUG
	' Now check if it matched or not
	' If oTCmatch.Count > 0 Then
	If oTCregx.Test(line) Then
		TCsuccess = True
		iTCTotCount  = iTCTotCount  + 1
		iTCFailCount = iTCFailCount + 1
		' Set TCremain to the (.*) part
		'max = oTCmatch(0).submatches.Count-1
		'TCremain = oTCmatch(0).submatches(max)
		TCremain = oTCregx.Replace (line, "")
		TClog replace_args ("==== Result: TC-{TCnum} OK")
	Else
		TCsuccess = False
		iTCTotCount  = iTCTotCount  + 1
		iTCFailCount = iTCFailCount + 1
		TClog replace_args ("==== Result: TC-{TCnum} #### FAILED ####")

	End If
 End Sub ' Sub TCcheckResult (line, expected)

 Set dir = Getref("ls")

 Sub ls (s)
	Set FSO = CreateObject("Scripting.FileSystemObject")
	Set objFolder = FSO.GetFolder(FSO.GetParentFolderName(WScript.ScriptFullName))
	Set allFiles = objFolder.Files
	For Each objFile in allFiles
		Wscript.StdOut.Write objFile.Name & " "
	Next
	Wscript.StdOut.WriteLine ""
 End Sub

 Sub fpath (s)
	Set fso = CreateObject("Scripting.FileSystemObject")
 	Set sh = CreateObject("WScript.Shell")

	For Each d In Split(sh.ExpandEnvironmentStrings("%PATH%"), ";")
		Wscript.StdOut.WriteLine d
		' TODO: 
		'		- Filter based on search string
		'		- Check if dir exists and mark with asterisk * or something 
		'		- Detect repeated items
		'		- Functions to add and remove stuff (?)

	Next
 End Sub




 :>

